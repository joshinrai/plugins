'use strict';

var THREE = require('three');

function particleMaterial3D(opt) {
  var scatterN = opt.scatterN;
  var maxOpacity = opt.maxOpacity;
  var maxPtSize = opt.maxPtSize || 1;
  var spriteUrl = opt.spriteUrl;
  var reverse = opt.reverseSpriteColor;
  var colorize = opt.color ? 1 : 0;
  var color = opt.color || {};
  var vertexShader =
    'uniform float maxSize;' +
    'attribute float valueList;' +

    'void main(){' +
    'vec3 pos = position;' +
    'vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );' +
    'vec4 mvPosition0 = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );' +

    'gl_Position = projectionMatrix * mvPosition;' +
    'float deg =  length(mvPosition0.xyz) / length(mvPosition.xyz);' +
    'gl_PointSize = abs(maxSize * valueList * cos(pos.y * 0.50) * pow(deg, 1.5));' +
    // 'gl_PointSize = 20.0;'+
    '}';

  var fragmentShader =
  'uniform float maxOpacity;' +
  'uniform float colorize;' +
  'uniform float reverse;' +
  'uniform float saturation;' +
  'uniform float value;' +
  'uniform float hue;' +

     'vec3 hsv2rgb(vec3 c)' +
      '{' +
      'vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);' +
      'vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);' +
      'return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);' +
      '}' +
    'uniform float time;' +
    'uniform sampler2D texture;' +

    'void main() {' +
    'vec2 uv = vec2(gl_PointCoord.x,gl_PointCoord.y);' +
    'vec4 color = vec4(hsv2rgb(vec3(hue,saturation,value)), maxOpacity);' +
    'vec4 texture2d =  texture2D(texture, uv);' +
    'if(reverse == 0.0 && colorize == 1.0){' +
     'gl_FragColor = color * texture2d;'  +
    '}' +
    'if(reverse == 1.0 && colorize == 1.0){' +
     'gl_FragColor = color * vec4(1.0-texture2d.r, 1.0-texture2d.g, 1.0-texture2d.b, texture2d.a);;'  +
    '} else if(reverse == 0.0 && colorize == 0.0){' +
      'gl_FragColor = texture2d;'  +
    '}else if(reverse == 1.0 && colorize == 0.0){' +
      'gl_FragColor = vec4(1.0-texture2d.r, 1.0-texture2d.g, 1.0-texture2d.b, texture2d.a);' + 
    '}' +
    '}';

  var valueList = [];
  for (var i = 0; i < scatterN; i++) {
    valueList.push(0);
  }

  var texture = THREE.ImageUtils.loadTexture(spriteUrl);
  texture.flipY = false;

  var uniforms = {
    'reverse': {
      'type': 'f',
      'value': reverse
    },
    'colorize': {
      'type': 'f',
      'value': colorize
    },
    'hue': {
      'type': 'f',
      'value': color.hue || 0
    },
    'saturation': {
      'type': 'f',
      'value': color.saturation * 100 || 0
    },
    'value': {
      'type': 'f',
      'value': color.value || 1
    },
    'texture': {
      'type': 't',
      'value': texture
    },
    'maxOpacity': {
      'type': 'f',
      'value': maxOpacity
    },
    'maxSize': {
      'type': 'f',
      'value': maxPtSize
    }
  };


  var attributes = {
    valueList: {
      type: 'f',
      value: valueList
    }
  };

  return new THREE.ShaderMaterial({
    uniforms: uniforms,
    attributes: attributes,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    blending: THREE.AdditiveBlending,
    depthTest: true,
    depthWrite: false,
    alphaTest: 1,
    transparent: true,
    shading: THREE.SmoothShading
  });
}

module.exports = particleMaterial3D;
