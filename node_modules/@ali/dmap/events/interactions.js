
  var $ = require('jquery');
  var THREE = require('three');
  var PI = Math.PI;
  var Utils = require('./../core/utils');
  var getPt = Utils.getPt;
  var requestAnimationFrame = Utils.requestAnimationFrame;
  var cancelAnimationFrame = Utils.cancelAnimationFrame;

  function Interaction(options) { //为node添加鼠标等交互事件
    this.defaults = {};

    this.variables();
    var containner = this.containner = $(options.containner);
    this.three3D = options.three3D;
    this.dom = options.dom;
    this._autoRotateSpeed = options.autoRotateSpeed;
    this.isMove2Rotate = true;
    this.isConsoleLogPosition = true;

    this.w = containner.width();
    this.h = containner.height();

    this.events();
    this.loop();
  }

  Interaction.prototype.variables = function () {
    this.mouse = {
      x: 0,
      y: 0
    };
    this.mouseOnDown = {
      x: 0,
      y: 0
    };
    this.target = {
      x: 9.801592653589791,
      y: 0.31579632679489666
    };
    this.rotation = {
      x: 0,
      y: 0
    };
    this.targetOnDown = {
      x: 0,
      y: 0
    };

    this.dCameraX = -500;
    this.dCameraY = 400;
    this.dCameraZ = 0;
    this.dCameraXTarget = 0;
    this.dCameraYTarget = 0;
    this.dCameraZTarget = 0;

    this.distance = 200;
    this.distanceTarget = 3.6199999999999988;
    this.distanceMax = 1600;
    this.distanceMinmin = 0.2;

    this.REarth = 10;
    this.overRenderer = false;

    this.dCameraXTargetOnDown = 0;
    this.dCameraYTargetOnDown = 0;
    this.dCameraZTargetOnDown = 0;

    this.changeBol = false;
    this.changingBol = false
    this.changeBolOld = false //辅助3d的canvas都在containar2上，当移动事件发生的时候，会自动清除。
  };

  Interaction.prototype.events = function () {
    var self = this;
    var containner = this.containner;
    containner.on('mousedown touchstart', this.mouseDown.bind(this));
    containner.on('mousewheel', this.mouseWheel.bind(this));
    $(window).on('resize', this.windowResize.bind(this));
    containner.on('mouseover', function () {
      self.overRenderer = true;
    });
    containner.on('mouseout touchup', function () {
      self.overRenderer = false;
    });
  };

  Interaction.prototype.loop = function () {
    this.update();
    requestAnimationFrame(this.loop.bind(this));
  };

  Interaction.prototype.update = function () {
    var three3D = this.three3D;
    var limit = 0.01;
    var rotateSpeed = 0.1;
    var scaleSpeed = 0.1;
    var moveSpeed = 0.3;

    var rotation = this.rotation;
    var target = this.target;
    var containner = this.containner;

    if(this._autoRotateSpeed && !this.isMouseDown){
      this.target.x += this._autoRotateSpeed;
    }

    if (Math.abs(target.x - rotation.x) + Math.abs(target.y - rotation.y) > limit) {
      rotation.x += (target.x - rotation.x) * rotateSpeed;
      rotation.y += (target.y - rotation.y) * rotateSpeed;

      containner.trigger('webgl-rotate', this);
    }

    if (Math.abs(this.distanceTarget - this.distance) > limit) {
      this.distance += (this.distanceTarget - this.distance) * scaleSpeed;
    }

    if (Math.abs(this.dCameraXTarget - this.dCameraX) + Math.abs(this.dCameraYTarget - this.dCameraY) + Math.abs(this.dCameraZTarget - this.dCameraZ) > limit) {
      this.dCameraX += (this.dCameraXTarget - this.dCameraX) * moveSpeed;
      this.dCameraY += (this.dCameraYTarget - this.dCameraY) * moveSpeed;
      this.dCameraZ += (this.dCameraZTarget - this.dCameraZ) * moveSpeed;
    }

    var positionx = this.distance * Math.sin(this.rotation.x) * Math.cos(this.rotation.y) + this.dCameraX;
    var positiony = this.distance * Math.sin(this.rotation.y) + this.dCameraY;
    var positionz = this.distance * Math.cos(this.rotation.x) * Math.cos(this.rotation.y) + this.dCameraZ;

    three3D.setCameraPosition(new THREE.Vector3(positionx, positiony, positionz));

    // viewX = REarth * Math.sin(rotation.x) * Math.cos(rotation.y);
    // viewY = REarth * Math.sin(rotation.y);
    // viewZ = REarth * Math.cos(rotation.x) * Math.cos(rotation.y);

    three3D.setCameraView(new THREE.Vector3(this.dCameraX, this.dCameraY, this.dCameraZ));
    this.change();
  };

  Interaction.prototype.mouseDown = function (e) { //鼠标落下的瞬间
    this.isMouseDown = true;
    
    var pos = getPt(e);
    this.mouseOnDown.x = -pos[0];
    this.mouseOnDown.y = pos[1];
    var eventType = pos[2];

    this.targetOnDown.x = this.target.x;
    this.targetOnDown.y = this.target.y;

    this.dCameraXTargetOnDown = this.dCameraXTarget;
    this.dCameraYTargetOnDown = this.dCameraYTarget;
    this.dCameraZTargetOnDown = this.dCameraZTarget;

    $(window).on('mousemove touchmove', this.mouseMove.bind(this));
    $(window).on('mouseup touchup touchleave', this.mouseUp.bind(this));
    e.preventDefault();
  };


  Interaction.prototype.mouseMove = function (e) { //鼠标落下并且移动 并非仅仅移动
    var pos = getPt(e);
    this.mouse.x = -pos[0];
    this.mouse.y = pos[1];
    var zoomDamp = this.distance / 1000;

    if (this.isMove2Rotate) { //移动映射旋转的情况
      this.target.x = this.targetOnDown.x + (this.mouse.x - this.mouseOnDown.x) * 0.005;
      this.target.y = this.targetOnDown.y + (this.mouse.y - this.mouseOnDown.y) * 0.005;
      this.target.y = this.target.y > PI / 2 ? PI / 2 : this.target.y;
      this.target.y = this.target.y < -PI / 2 ? -PI / 2 : this.target.y;
    } else { //移动映射移动的情况
      this.dCameraXTarget = this.dCameraXTargetOnDown + (this.mouse.x - this.mouseOnDown.x) * zoomDamp * Math.cos(this.target.x);
      this.dCameraZTarget = this.dCameraZTargetOnDown + (this.mouse.y - this.mouseOnDown.y) * zoomDamp * Math.sin(-this.target.x);
    }
  };

  Interaction.prototype.mouseUp = function (event) {
    this.isMouseDown = false;
    var node = $(window);
    node.off('mousemove');
    node.off('mouseup');

    this.eventsOff();

    if(!this.isConsoleLogPosition) return;
    console.log(
      '{'+
      '\'dCameraYTarget\': ' + this.dCameraYTarget + ',' +
      '\'dCameraXTarget\': ' + this.dCameraXTarget + ',' +
      '\'dCameraZTarget\': ' + this.dCameraZTarget + ',' +
      '\'distanceTarget\': ' + this.distanceTarget + ',' +
      '\'targetx\': ' + this.target.x + ',' +
      '\'targety\': ' + this.target.y + '}'
    );
  };

  Interaction.prototype.eventsOff = function (event) {
    var node = $(window)
    node.off('mousemove');
    node.off('mouseup');
    node.off('mouseout');
  }

  Interaction.prototype.mouseWheel = function (event) {
    event.preventDefault();
    if (this.overRenderer) {
      this.zoom(event.originalEvent.wheelDeltaY * 0.02);
    }
    return false;
  };


  Interaction.prototype.flyingTo = function (meshes, ratio, offsetX, offsetY) { //暂时只试用于平面情况

    ratio = ratio || 0.75 // ratio为占屏幕的比重
    offsetX = offsetX || 0;
    offsetY = offsetY || 0;

    var max, min;
    for (var k in meshes) {
      var mesh = meshes[k]
        // mesh.material.color=color

      var geo = mesh.geometry;
      geo.computeBoundingBox();
      var boundingBox = geo.boundingBox;

      if (k == 0) {
        max = boundingBox.max.clone()
        min = boundingBox.min.clone()
      }

      if (max.x < boundingBox.max.x) {
        max.x = boundingBox.max.x
      }
      if (max.y < boundingBox.max.y) {
        max.y = boundingBox.max.y
      }
      if (max.z < boundingBox.max.z) {
        max.z = boundingBox.max.z
      }
      if (min.x > boundingBox.min.x) {
        min.x = boundingBox.min.x
      }
      if (min.y > boundingBox.min.y) {
        min.y = boundingBox.min.y
      }
      if (min.z > boundingBox.min.z) {
        min.z = boundingBox.min.z
      }
    }

    var width = this.w;
    var height = this.h;

    var xMax = max.x;
    var yMax = max.y;
    var zMax = max.z;
    var xMin = min.x;
    var yMin = min.y;
    var zMin = min.z;
    var width3D = Math.abs(xMax - xMin);
    var height3D = Math.abs(yMax - yMin);
    var cx = (xMax + xMin) / 2;
    var cy = (yMax + yMin) / 2;
    var cz = (zMax + zMin) / 2;
    var dx = (xMax - xMin)
    var dy = (yMax - yMin)
    var dz = (zMax - zMin)
    var center = new THREE.Vector3(cy, cz, cx);
    if (height3D) {
      if (width3D / height3D > self.w / self.h) {
        width3D = height3D * self.w / self.h;
      }
    }

    var camera = this.three3D.getCamera();
    var angle = camera.fov / 360 * PI;

    this.dCameraXTarget = -cy + offsetY;
    this.dCameraZTarget = -cx + offsetY;
    this.dCameraYTarget = 0

    this.target.x = PI;
    this.target.y = PI / 2
  };


  Interaction.prototype.flyingChina = function (type) {
    var target = this.target;
    this.dCameraXTarget = -16.9;
    this.dCameraYTarget = 1.5;
    this.dCameraZTarget = 8;
    this.distanceTarget = 9.5;

    if (type === 'top') {
      target.x = PI;
      target.y = PI / 2
    } else if (type === 'low') {
      this.dCameraZTarget = 6.0;
      this.dCameraYTarget = 1;
      target.x = 3.1465926535897935;
      target.y = 0.5457963267948965;
    }
  };


  Interaction.prototype.flyingEarthSphere = function () {
    this.dCameraYTarget = 0;
    this.dCameraXTarget = 0;
    this.dCameraZTarget = 0;
    this.distanceTarget = 3.200000000000007;
    this.target.x = -9.523407346410208;
    this.target.y = 0.35579632679489653;
  };

  Interaction.prototype.flyingEarthPlane = function () {
    this.dCameraYTarget = 0;
    this.dCameraXTarget = 0;
    this.dCameraZTarget = 0;
    this.distanceTarget = 3.200000000000007;
    this.target.x = 0.0015926535897930333;
    this.target.y = 0.8057963267948965;
  };



  Interaction.prototype.flying = function (obj) {
    var target = this.target;
    this.dCameraYTarget = obj.dCameraYTarget;
    this.distanceTarget = obj.distanceTarget;
    this.dCameraXTarget = obj.dCameraXTarget;
    this.dCameraZTarget = obj.dCameraZTarget;
    target.x = obj.targetx;
    target.y = obj.targety;
  };

  Interaction.prototype.flyingDirect = function (obj) {
    this.flying(obj);
    var rotation = this.rotation;
    this.dCameraY = obj.dCameraYTarget;
    this.distance = obj.distanceTarget;
    this.dCameraX = obj.dCameraXTarget;
    this.dCameraZ = obj.dCameraZTarget;
    rotation.x = obj.targetx;
    rotation.y = obj.targety;
  };

  Interaction.prototype.distanceFlying = function (option1, option2) {
    return Math.abs(option1.obj.dCameraXTarget - option2.obj.dCameraXTarget) + Math.abs(option1.obj.dCameraYTarget - option2.obj.dCameraYTarget) + Math.abs(option1.obj.dCameraZTarget - option2.obj.dCameraZTarget) + Math.abs(option1.target.x - option2.target.x) + Math.abs(option1.target.y - option2.target.y);
  };

  Interaction.prototype.windowResize = function (event) {
    var three3D = this.three3D;
    var node = this.containner;

    var camera = three3D.getCamera();
    camera.aspect = node.width() / node.height();
    camera.VIEW_ANGLE = 260;
    three3D.setSize(node.width(), node.height());
  }

  Interaction.prototype.zoom = function (delta) {
    this.distanceTarget -= delta;
    this.distanceTarget = this.distanceTarget > this.distanceMax ? this.distanceMax : this.distanceTarget;
    this.distanceTarget = this.distanceTarget < this.distanceMinmin ? this.distanceMinmin : this.distanceTarget;
  }

  Interaction.prototype.change = function () {
    var changeBol = this.changeBol = false;
    var changingBol = this.changingBol = false;
    var changeBolOld = this.changeBolOld;

    var limit = 0.001;

    var rotation = this.rotation;
    var rotationOld = this.rotationOld || JSON.parse(JSON.stringify(rotation));
    var distance = this.distance || 0;
    var dCameraXOld = this.dCameraXOld || 0;
    var dCameraYOld = this.dCameraYOld || 0;
    var dCameraZOld = this.dCameraZOld || 0;
    var distanceOld = this.distanceOld || 0;

    var delta = Math.abs(rotation.x - rotationOld.x) + Math.abs(rotation.y - rotationOld.y) + Math.abs(this.distance - distanceOld) + Math.abs(this.dCameraZ - dCameraZOld) + Math.abs(this.dCameraX - dCameraXOld);
    if (delta > limit) { //当各种量的变化加起来超过一定，算运动
      changeBol = true;
      $('body').trigger('webgl-change');
    }
    if (changeBolOld != changeBol) {
      if (!changeBolOld) {
        $('body').trigger('webgl-changing-begin');
      } else {
        $('body').trigger('webgl-changing-end');
      }
      $('body').trigger('webgl-changing');
      changingBol = true;
    }
    if (changeBolOld == changeBol) {
      changingBol = false;
    }

    rotationOld.x = rotation.x;
    rotationOld.y = rotation.y;
    this.rotationOld = rotationOld;
    this.distanceOld = this.distance;
    this.dCameraXOld = this.dCameraX;
    this.dCameraZOld = this.dCameraZ;
    this.changeBolOld = changeBol;
  };

  module.exports = Interaction;
