'use strict';
var Utils = require('./../core/utils');
var mercator = Utils.mercator;
var sphere = Utils.sphere;
var THREE = require('three');
var Utils = require('@ali/map-utils');
var requestAnimationFrame = Utils.requestAnimationFrame;
var cancelAnimationFrame = Utils.cancelAnimationFrame;
/**
 * FlyingLine 飞线模块
 * @param {Object} opt 配置
 */
function FlyingLine (opt) {
  var id = this.id = 'flyingline_' + Math.floor(Math.random()*1000000000);
  var list = this._list = opt.list;
  list[id] = this;
  this.life = 0;
  this.flyingBol = false;
  this.pointingBol = false;
  if(!opt) console.log('FlyingLine_无数据输入');
  this.three3D = opt.three3D;
  this._ptN = opt.ptN || 10;
  this._weight = opt.weight || 2;
  this._hue = opt.hue || 0.5;
  this._kHeight = opt.kHeight || 2;
  this._range = opt.range || 0.8;
  this._lifeSpeed = opt.lifeSpeed || 0.002;
  this._maxOpacity = opt.maxOpacity || 1;
  this._opacityLimit = opt.opacityLimit || 0.04;
  var center = this._center = opt.center || new THREE.Vector3(0, 0, 0);
  var REarth = this._REarth = opt.REarth || 1.015;
  this._ptSize = opt.ptSize || 0.02;
  this._ptNormalSpeed = opt.ptNormalSpeed || 0.001;
  this._ptExpandSpeed = opt.ptExpandSpeed || 0.01;
  var mapType = this.mapType = opt.mapType || 'sphere';

  if (mapType === 'sphere') {
    this._transfer = function(lng, lat){
      return sphere(lng, lat, REarth);
    };
    this._getNormal = function(){
      var ptFrom = this.ptFrom;
      var ptTo = this.ptTo;
      if(!ptFrom || !ptTo) return;
      return ptFrom.clone().lerp(ptTo, 0.5).sub(center).normalize();
    };
  }else if (mapType === 'plane') {
    this._transfer = function (lng, lat) {
      return mercator(lng, lat, REarth);
    };
    this._getNormal = function () {
      return new THREE.Vector3(0, 1, 0);
    };
  }
  this.init();
  this.loop();
}

/**
 * data 流式的数据灌入
 * @param  {Object} d 数据 如 
 * {
   from: {
     lat: 0,
     lng: 0
   },
   to: {
     lat: 30,
     lng: 120
   }
 }
 */
FlyingLine.prototype.data = function (d) {
  var from = d.from;
  var to = d.to;
  var ptFrom = this.ptFrom = this._transfer(from.lng, from.lat);
  var ptTo = this.ptTo = this._transfer(to.lng, to.lat);
  this.distance = ptFrom.distanceTo(ptTo);
  this.start();
};

/**
 * start 开始飞线
 */
FlyingLine.prototype.start = function() {
  this.flyingBol = true;
  this.line.visible = true;
};


/**
 * _getPt 通过percent 生成点的位置
 * @param  {Float} percent  飞线飞的百分比 0-1 
 */
 FlyingLine.prototype._getPt = function(percent){
    var kHeight = this._kHeight;
    var ptFrom = this.ptFrom;
    var ptTo = this.ptTo;
    var normal = this._getNormal();
    var h = (1 - percent) * percent * kHeight * this.distance;
    var ptPercent = ptFrom.clone().lerp(ptTo, percent).add(normal.multiplyScalar(h));
    return ptPercent;
  };

/**
 * update 循环 更新飞线位置
 */
FlyingLine.prototype.update = function () {
  if(this.flyingBol) {
    this.life += this._lifeSpeed;
    this.updatePos();
  }else if(this.pointingBol) {
    this.updatePt();
  }
  this.geometry.verticesNeedUpdate = true;
};

FlyingLine.prototype.loop = function () {
  this.update();
  requestAnimationFrame(this.loop.bind(this));
};

/**
 * updatePos 更新飞线位置
 */
FlyingLine.prototype.updatePos = function() {
  var range = this._range;
  var ptN = this._ptN;
  var life = this.life;
  var getPt = this._getPt.bind(this);
  var vertices = this.vertices;
  var percent;
  for(var k = 0; k < ptN; k++ ){
    var ki = k/ptN;
    if(range > life){
      percent = (1 - ki) * life;
    } else if (life < 1) {
      percent = life - ki * range;
    } else if (life > 1 && life < 1 + range){
      percent = 1 - (range - life + 1) * ki;
    } else{
      return this.doneFlying();
    }
    vertices[k] = getPt(percent);
  }
};

/**
 * updatePt 更新点位置
 */
FlyingLine.prototype.updatePt = function() {
  var ptNormalSpeed = this._ptNormalSpeed;
  var ptExpandSpeed = this._ptExpandSpeed;
  var opacityLimit = this._opacityLimit;
  var targetList = this.targetList;
  var vertices = this.vertices;
  var uniforms = this.material.uniforms;
  var normal = vertices[0].clone().sub(this._center).normalize();
  for(var k in vertices){
    var vertice = vertices[k];
    var verticeTarget = targetList[k].vertice;
    vertice
    .lerp(verticeTarget, ptExpandSpeed)
    .add(normal.clone().multiplyScalar(ptNormalSpeed));
    var opacity = uniforms.maxOpacity.value;
    if(opacity < opacityLimit){
      return this.done();
    }
    uniforms.maxOpacity.value = opacity*(1 - ptExpandSpeed/50);
  }
};

/**
 * done 完成飞线
 */
FlyingLine.prototype.doneFlying = function() {
  this.flyingBol = false;
  if(this._ptExpandSpeed){
    this.toPoint();
    this.pointingBol = true;
  } else {
    this.done();
  }
  // this.line.visible = false;
  this.toPoint();
};

/**
 * done 整个过程结束
 */
FlyingLine.prototype.done = function() {
  this.flyingBol = false;
  this.pointingBol = false;
  this.line.visible = false;
  this.remove();
};

/**
 * init 建立飞线
 */
FlyingLine.prototype.init = function() {
  var ptN = this._ptN;
  var hue = this._hue;
  var geometry = this.geometry = new THREE.Geometry();
  var vertices = this.vertices = geometry.vertices;
  var colors = [], indexes = [];
  for (var i = ptN - 1; i >= 0; i--) {
    var k = i/ptN;
    var c = new THREE.Color().setHSL(hue, 1 - k * 0.8 , 0.3 + k * 0.3);
    colors.push(new THREE.Vector4(c.r, c.g , c.b, k));
    indexes.push(k);
    vertices.push(new THREE.Vector3(0, 0, 0));
  }
  var material = this.material = this.genMaterial(colors, indexes);
  var line = this.line = new THREE.Line(geometry, material);
  line.visible = false;
  this.three3D.add(line);
};

FlyingLine.prototype.toPoint = function(){
  var ptSize = this._ptSize;
  var vertices = this.vertices;
  var cos = Math.cos, sin = Math.sin, random = Math.random, PI = Math.PI, dx, dy, dz, theta, phi, vertice, ki;
  var N = vertices.length;
  var targetList = this.targetList = [];
  for(var k = 0; k < N; k++){
    ki = k / N;
    vertice = vertices[k];
    theta = PI * random();
    phi = 2 * PI * random();
    dx = ki * ptSize * cos(theta) * cos(phi);
    dz = ki * ptSize * sin(theta) * cos(phi);
    dy = ki * ptSize * sin(phi);
    targetList.push({
      vertice: new THREE.Vector3(vertice.x + dx,vertice.y + dy, vertice.z + dz),
      opacity: 0
    });
  }
  this.material.linewidth = 10;
};

/**
 * remove 移除飞线
 */
FlyingLine.prototype.remove = function () {
  this.three3D.remove(this.line);
  delete this.material;
  delete this.vertices;
  delete this.targetList;
  delete this._list[this.id];
};

/**
 * genMaterial 生成颜色材质
 * @param  {Array} colors  点的颜色序列
 * @param  {Array} indexes 点的序号
 */
FlyingLine.prototype.genMaterial = function (colors, indexes) {
  var vertexShader =
  'attribute vec4 colors;' + 
  'attribute float indexes;' + 
  'varying vec4 c;' + 
  'varying float index;' + 
  'void main(){' + 
    'c = colors;' + 
    'index = indexes;' +
    'vec3 pos = position;' + 
    'vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );' + 
    'gl_Position = projectionMatrix * mvPosition;' + 
    'gl_PointSize = 120.0;' +
  '}';

  var fragmentShader = 
  'varying vec4 c;' +
  'uniform float maxOpacity;' +
  'varying float index;' +
  'void main() {' +
    'gl_FragColor = c * vec4(1, 1, 1, maxOpacity);'+
  '}';

  var uniforms = {
    maxOpacity:{
      type: 'f',
      value: this._maxOpacity
    }
  };
  var attributes = {
    colors: {
      type: 'v4',
      value: colors
    },
    indexes: {
      type: 'f',
      value: indexes
    },
  };

  return new THREE.ShaderMaterial({
    'uniforms': uniforms,
    'attributes': attributes,
    'vertexShader': vertexShader,
    'fragmentShader': fragmentShader,
    'vertexColors': THREE.VertexColors,
    'blending': THREE.AdditiveBlending,
    'depthTest': true,
    'depthWrite': false,
    'alphaTest': 1,
    'transparent': true,
    'shading': THREE.SmoothShading,
    'side': THREE.DoubleSide,
    'diffuse': 0x5cd7ff,
    'linewidth':this._weight,
    'linejoin': 'round',
    'linecap': 'round',
    'fog': true,
  });
};

module.exports = FlyingLine;
