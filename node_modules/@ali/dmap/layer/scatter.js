'use strict';
var Utils = require('./../core/utils');
var _ = require('lodash');
var isNone = Utils.isNone;
var mercator = Utils.mercator;
var sphere = Utils.sphere;
var genSphereParticles = Utils.genSphereParticles;
var particleMaterial3D = require('./../render/particleMaterial3D');
var THREE = require('three');
var TWEEN = require('tween.js');

/**
 * Scatter 在3d平面上 生成一系列点图
 * @param {Object} opt 配置
 */
function Scatter(opt) {
  if(!opt) console.log('Scatter_无数据输入');
  this.three3D = opt.three3D;
  this._scatterN = opt.scatterN || 1000;
  this._color = opt.color;
  this._maxPtSize = opt.maxPtSize || 5;
  this._valueMax = opt.valueMax;
  this._REarth = opt.REarth || 1.04;
  this._maxOpacity = opt.maxOpacity;
  this._sprite = opt.sprite || 'flat';
  this._reverseSpriteColor = opt.reverseSpriteColor || 0;
  this._data = {};
  var mapType = this.mapType = opt.mapType || 'sphere';
  if (mapType === 'sphere') {
    this.transfer = sphere;
  }else if ((mapType === 'plane')) {
    this.transfer = mercator;
  }
  this.initParticles();
}

/**
 * data 流式的数据灌入
 * @param  {Object} ds 数据
 */
Scatter.prototype.data = function (ds) {
  var lat, lng, pt, key, vertice, d, pos, valueFormat;
  var scatterN = this._scatterN;
  var vertices = this.particleGeometry.vertices;
  var transfer = this.transfer;
  var REarth = this._REarth;
  var data = this._data;
  var material = this.material;
  var attributes = material.attributes;
  var valueMax = isNone(this._valueMax)? _.max(ds, function (d){return d.value;}).value : this._valueMax;
  for (var i in ds) {
    d = ds[i];
    pos = d.cp || d.pos;
    if (pos) {
      lat = pos.lat, lng = pos.lng;
    } else {
      lat = d.lat, lng = d.lng;
    }
    pt = transfer(lng, lat, REarth, 0, 0, 0);
    d.valueFormat = valueFormat = d.value / valueMax;
    key = i;
    if (!data[key]) {
      data[key] = d;
      d.verticleIndex = this.verticeUsedIndex;
      this.verticeUsedIndex = (this.verticeUsedIndex + 1) % scatterN;
    }
    var verticleIndex = data[key].verticleIndex;
    attributes.valueList.value[verticleIndex] = valueFormat;
    vertice = vertices[verticleIndex];
    vertice.x = pt.x;
    vertice.y = pt.y;
    vertice.z = pt.z;
  }
};

/**
 * initParticles 生成初始化粒子系统
 */
Scatter.prototype.initParticles = function () {
  var scatterN = this._scatterN;
  var maxPtSize = this._maxPtSize || 30;
  var three3D = this.three3D;
  var spriteUrl, sprite = this._sprite;
  if (typeof (sprite) === 'string') {
    spriteUrl = {
      'flat': function () {
        return Utils.generateCircle('#fff', 100).toDataURL();
      },
      'gradient': function () {
        return Utils.generateSprite('rgba(0,0,0,0)', 'rgba(250,250,250,1)', 80).toDataURL();
      }
    }[sprite]();
  } else if (typeof (sprite) === 'function') {
    spriteUrl = sprite();
  } else if (typeof (sprite) === 'object') {
    spriteUrl = sprite.url;
  }

  var material = this.material = particleMaterial3D({
     'maxPtSize': maxPtSize,
     'color': this._color,
     'spriteUrl': spriteUrl,
     'scatterN': scatterN,
     'maxOpacity': this._maxOpacity,
     'reverseSpriteColor': this._reverseSpriteColor
   });
  var particleGeometry = this.particleGeometry = genSphereParticles(10, 1, scatterN);
  var pointCloud = this.pointCloud = new THREE.PointCloud(particleGeometry, material);
  this.verticeUsedIndex = 0;//被使用的粒子数
  three3D.add(pointCloud);
};

/**
 * loop 循环 使材质更新
 */
Scatter.prototype.loop = function () {
  this.material.attributes.valueList.needsUpdate = true;
  this.material.needsUpdate = true;
};

/**
 * remove 移除粒子系统
 */
Scatter.prototype.remove = function () {
  this.three3D.remove(this.pointCloud);
};

module.exports = Scatter;
