//生成数组的库
//野狩

'use strict';
var THREE = require('three');
var $ = require('jquery');
var Utils = require('./../core/utils');
var mercator = Utils.mercator;
var sphere = Utils.sphere;
var subdivideOnSphere = Utils.subdivideOnSphere;
var divideby = Utils.divideby;
var traver = Utils.traver;
var isNone = Utils.isNone;

/**
 * @class  Area
 * @param {Object} options
 *    - mapType {String}  投影方式 `plane` , `sphere`
 *    - REarth {String} 地球半径
 *    - fill {String, Object} fill如果是Object 可包含的信息包括
 */
function Area(options) { //每导入一次地理数据调用下这个函数，geometry会判断输入类型并对数据进行处理
  this.three3D = options.three3D;
  this.options = options;
}

Area.prototype.render = function (geojson, opt) {
  if (!geojson) {
    return console.log('没有geojson');
  }
  opt = $.extend(opt, this.options);
  var mapType = opt.mapType || 'sphere';
  var transferFunc = (mapType === 'plane') ? mercator : sphere; //投影函数

  //fill相关的配置和函数
  var fill = this.fill = opt.fill;
  if (fill) {
    var fillFunc = this.genFill(fill);
  }

  // stroke 相关的配置和函数
  var stroke = this.stroke = opt.stroke;
  if (stroke) {
    var strokeFunc = this.genStroke(stroke);
  }

  var REarth = this.REarth = opt.REarth || 1;

  var transfer = this.transfer = function (lng, lat) { //投影转换函数
    return transferFunc(lng, lat, REarth);
  };

  var geoID = opt.geoID || geojson.id;
  if (!geoID) return console.log('数据没有id');
  var geo = this.geo = this.geo || {};

  var properties, id, coordinates, cp, item;
  var traverArray = this.traverArray.bind(this);
  traver(geojson, function (key, child, parent) {
    if (key !== 'geometry') { return true;}
    id = parent.id;
    item = geo[id] = geo[id] || {};

    properties = parent.properties;
    
    //行政中心点的坐标
    cp = child.coordinate || parent.cp || properties.cp || properties.coordinate;
    if (cp) {
      item.cp = cp;
      var lat = cp.lat || cp[0];
      var lng = cp.lng || cp[1];
      item.cp3D = transfer (lng, lat);
    }
    //行政区域名字
    if (properties.cName) {
      item.cName = properties.cName;
    }
    //填充材质
    if (fill) {
      fillFunc(item);
      item.fillGeometry = [];
    }
    //边线材质
    if (stroke) {
      strokeFunc(item);
      item.strokeGeometry = [];
    }

    coordinates = child.coordinates;
    traverArray(coordinates, item);
    return false;
  });
};


Area.prototype.traverArray = function (coordinates, item) { //MultiPolygon和Polygon经常不准确，所以直接遍历
  for (var k in coordinates) {
    if (typeof (coordinates[k][0]) !== 'object') {
      this.pts2Mesh.bind(this)(coordinates, item);
      break;
    } else {
      this.traverArray.bind(this)(coordinates[k], item);
    }
  }
};

/**
 * pts2Mesh 将点阵转化成几何体
 * @pts  {Array} 输入的点阵
 * @item  {Object} 区域对象
 */
Area.prototype.pts2Mesh = function (pts, item) {
  var geoObj = this.pts2MeshGeo(pts, item);
  if (geoObj) {
    var three3D = this.three3D;

    var fillGeometry = geoObj.fillGeometry;
    var strokeGeometry = geoObj.strokeGeometry;

    if (fillGeometry) { //填充颜色的mesh绘制
      var material = item.material;
      if (!material) {
        return;
      }
      if (this.mapType === 'sphere') {
        fillGeometry = subdivideOnSphere(fillGeometry, this.REarth, 0, 0, 0);
      }
      var mesh;
      if (typeof(material) === 'function') {
        mesh = material(fillGeometry);
      } else if (typeof(material) === 'object') {
        mesh = new THREE.Mesh(fillGeometry, material);
      }
      mesh.position.set(0, 0, 0);
      three3D.add(mesh);
      item.fillGeometry.push(mesh);
    }

    if (strokeGeometry) { //勾边部分的绘制
      var strokeMaterial = item.strokeMaterial;
      strokeGeometry.computeLineDistances();
      var mesh;
      mesh = new THREE.Line(strokeGeometry, strokeMaterial);
      mesh.position.set(0, 0, 0);
      three3D.add(mesh);
      item.strokeGeometry.push(mesh);
    }
  }
};

/**
 * pts2MeshGeo 将点阵转化成几何体（geometry)
 * @params {Array} pts 输入的点阵
 * @params {Object} item 区域对象
 */
Area.prototype.pts2MeshGeo = function (pts, item) {
  var transfer = this.transfer;
  var stroke = this.stroke;
  var fill = this.fill;
  var divide = this.divide;
  //给定一组经纬度的数组，画出地理边界或是区域,返回没有附材质的geometry
  var shape = new THREE.Shape();
  var spherePtList = [];
  var ptTarget, pt, x, z, exist;
  var xPrev = 0.00001,
    zPrev = 0.00001,
    lat, lng;
  for (var j = 0; j < pts.length; j++) {
    lat = pts[j][1];
    if (divide) {
      lat = divideby(lat, divide);
    }
    lng = pts[j][0];
    if (divide) {
      lng = divideby(lng, divide);
    }

    pt = mercator(lng, lat, 1);
    ptTarget = transfer(lng, lat);
    x = pt.x;
    z = pt.z;
    exist = !isNone(x) && !isNone(z);
    if (j === 0 && exist) {
      shape.moveTo(-z, -x);
      spherePtList.push(ptTarget);
      xPrev = x;
      zPrev = z;
    }
    if (j !== 0 && ((xPrev !== x) || (zPrev !== z)) && exist) { //防止点重复，即长度为0的直线
      shape.lineTo(-z, -x);
      spherePtList.push(ptTarget);
      xPrev = x;
      zPrev = z;
    }
  }
  var vertices, vertice;
  if (spherePtList.length) {
    var strokeGeometry, fillGeometry;
    if (fill) {
      fillGeometry = new THREE.ShapeGeometry(shape);
      vertices = fillGeometry.vertices;
      for (var k = 0; k < vertices.length; k++) {
        ptTarget = spherePtList[k];
        var vertice = vertices[k];
        if (vertice && ptTarget) {
          vertice.x = ptTarget.x;
          vertice.z = ptTarget.z;
          vertice.y = ptTarget.y;
        }
      }
    }
    if (stroke) {
      strokeGeometry = new THREE.Geometry();
      vertices = strokeGeometry.vertices;
      for (var k = 0; k < spherePtList.length; k++) {
        ptTarget = spherePtList[k];
        vertice = new THREE.Vector3();
        vertice.x = ptTarget.x;
        vertice.z = ptTarget.z;
        vertice.y = ptTarget.y;
        vertices.push(vertice);
      }
    }
    return {
      'strokeGeometry': strokeGeometry,
      'fillGeometry': fillGeometry
    };
    // shapeGeometry.buffersNeedUpdate = true;
    // shapeGeometry.uvsNeedUpdate = true;
    // shapeGeometry.computeFaceNormals();
  }
  return false;
};

/**
 * genFill 根据配置生成材质的函数
 * @param {Object} fill fill相关的配置
 */
Area.prototype.genFill = function (fill) {
  var opacity = fill.opacity;
  var fillOpt = {
    // 'transparent': opacity ? 1 : 0,
    'opacity': opacity ? opacity : 1,
    'bumpScale': 1,
    'shininess': 15,
    'normalScale': new THREE.Vector2(1.5, 1.5),
    'wrapRGB': new THREE.Vector3(0.99, 0.99, 0.99),
    'combine': THREE.AddOperation,
    'wrapAround': true,
    'wireframeLinecap': 'round',
  };
  var fillOptBack = $.extend({
    'transparent': 0,
    'color': fill.colorBack || 0x222222,
    'side': THREE.BackSide,
    'specular': fill.colorBack || 0x222222
  }, fillOpt);

  var fillOptFront = $.extend({
    'transparent': 0,
    'color': fill.colorFront || 0x440000,
    'side': THREE.FrontSide,
    'specular': fill.colorFront || 0x440000
  }, fillOpt);

  var fillType = fill ? fill.type : 'none';

  return {
    'triangle': function (item) {
      item.material = function (geometry) {
        geometry.computeFaceNormals();
        var matBack = new THREE.MeshPhongMaterial(fillOptBack);
        var matFront = new THREE.MeshPhongMaterial(fillOptFront);
        return THREE.SceneUtils.createMultiMaterialObject(geometry, [matBack, matFront]);
      };
    },
    'none': function (item) {
      return item;
    },
    'flat': function (item) {
      var matBack = new THREE.MeshBasicMaterial(fillOptBack);
      var matFront = new THREE.MeshBasicMaterial(fillOptFront);
      item.material = function (geometry) {
        return THREE.SceneUtils.createMultiMaterialObject(geometry, [matBack, matFront]);
      };
    }
  }[fillType];
};

/**
 * genStroke 根据配置生成边线材质的函数
 *params {Object} stroke  stroke相关的配置
 */
Area.prototype.genStroke = function (stroke) {
  var strokeType = stroke ? stroke.type : null;
  return {
    dash: function (item) {
      var color = stroke.color || 0xffffff;
      var opacity = stroke.opacity;
      var strokeMaterial = new THREE.LineDashedMaterial({
        'linewidth': stroke.width || 3,
        'color': color,
        'dashSize': 0.008,
        'gapSize': 0.005,
        'transparent': opacity ? 1 : 0,
        'opacity': opacity ? opacity : 1,
      });
      item.strokeMaterial = strokeMaterial;
    },
    default: function (item) {
      var color = stroke.color || 0xffffff;
      var opacity = stroke.opacity;
      var strokeMaterial = new THREE.LineBasicMaterial({
        'linewidth': stroke.width || 3,
        'color': color,
        'transparent': opacity ? 1 : 0,
        'opacity': opacity ? opacity : 1,
      });
      item.strokeMaterial = strokeMaterial;
    }
  }[strokeType];
};

Area.prototype.loop = function () {
};

module.exports = Area;