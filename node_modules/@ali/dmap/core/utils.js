'use strict';
var THREE = require('three');
var Utils = require('@ali/map-utils');
var $ = require('jquery');
var cos = Math.cos,
  sin = Math.sin,
  atan2 = Math.atan2,
  asin = Math.asin,
  sqrt = Math.sqrt,
  random = Math.random,
  pow = Math.pow,
  min = Math.min,
  tan = Math.tan,
  PI = Math.PI,
  log = Math.log,
  max = Math.max;

/**
 * getPt 获取事件中的x、 y坐标（相对父容器，兼容touch和mouse事件
 * @param  {Object} 事件
 * @return {[type]}   [description]
 */
function getPt (e) { //获取点相对于容器的位置
  var node = $(e.target);
  var nodeW = node.width();
  var nodeH = node.height();
  var offset = node.offset();
  var left = offset.left;
  var top = offset.top;
  var x, y;
  if (e.type.indexOf('mouse') !== -1) {
    x = e.x || e.pageX;
    y = e.y || e.pageY;
    return [x - left, y - top, 'mouse'];
  }
  var touch = window.event.touches[0];
  x = touch.pageX - left;
  y = touch.pageY - top;
  x = (x < nodeW) ? x : nodeW;
  x = (x > 0) ? x : 1;
  y = (y < nodeH) ? y : nodeH;
  y = (y > 0) ? y : 1;
  return [x, y, 'touch'];
}

/**
 * mercator 墨卡托变换
 * @param {float} lng 经度
 * @param {float} lat 纬度
 * @param {float} REarth 地球半径
 * @param {float} z 中心点的x坐标
 * @param {float} y 中心点的y坐标
 * @param {float} z 中心点的z坐标
 * @return {Object} 投影后的3D点
 */
function mercator(lng, lat, REarth, x, y, z) {
  x = x || -1.5;
  y = y || -0.5;
  z = z || 1.3;
  REarth = REarth || 1;
  return new THREE.Vector3(lng / 180 * PI * REarth + x, y, - REarth * log(tan((90 + lat) * PI / 360)) + z);
}

/**
 * sphere 球面变换
 * @param {float} lng 经度
 * @param {float} lat 纬度
 * @param {float} REarth 地球半径
 * @param {float} z 中心点的x坐标
 * @param {float} y 中心点的y坐标
 * @param {float} z 中心点的z坐标
 * @return {Object} 投影后的3D点
 */
function sphere(lng, lat, REarth, x0, y0, z0) {
  var ratio = 1; //考虑椭球的情况，ratio可能不为1
  x0 = x0 || 0;
  y0 = y0 || 0;
  z0 = z0 || 0;
  REarth = REarth || 1;
  var theta = - lng * PI / 180;
  var phi = lat * PI / 180;

  var x = REarth * cos(theta) * cos(phi) * ratio + x0;
  var z = REarth * sin(theta) * cos(phi) * ratio + z0;
  var y = REarth * sin(phi) + y0;
  return new THREE.Vector3(x, y, z);
}

function getLatlngSphere(x, y, z, REarth, x0, y0, z0) {// 有待验证
  x0 = x0 || 0;
  y0 = y0 || 0;
  z0 = z0 || 0;
  REarth = REarth || 1;
  var dx = x - x0;
  var dy = y - y0;
  var dz = z - z0;
  var lat = asin(dy / REarth);
  var lng = atan2(dz, dx);
  return {
    lat: lat,
    lng: lng
  };
}

/**
 * getAreaTriangle3d 根据三个点计算三角形面积
 * @param {Object} p1 点1
 * @param {Object} p2 点2
 * @param {Object} p3 点3
 * @return {float} 面积
 */
function getAreaTriangle3d(p1, p2, p3) { 
  var x1 = p2.x - p1.x;
  var y1 = p2.y - p1.y;
  var z1 = p2.z - p1.z;
  var x2 = p3.x - p2.x;
  var y2 = p3.y - p2.y;
  var z2 = p3.z - p2.z;
  return 0.5 * sqrt(pow(y1 * z2 - z1 * y2, 2) + pow(x1 * z2 - z1 * x2, 2) + pow(x1 * y2 - y1 * z2, 2));
}

/**
 * projectPtOnSphere 点投影到球面的坐标
 * @param  {Object} pt 投影前的坐标
 * @param  {float} cx球的x坐标
 * @param  {float} cy 球的y坐标
 * @param  {float} cz 球的z坐标
 * @param {float} r 球半径
 * @return {Object} 投影后的坐标
 */
function projectPtOnSphere(pt, r, cx, cy, cz) { //
  var x = pt.x;
  var y = pt.y;
  var z = pt.z;
  var dx = x - cx;
  var dy = y - cy;
  var dz = z - cz;
  var distance = sqrt(dx * dx + dy * dy + dz * dz);
  var phi = (distance < r) ? r / distance : 1;
  return new THREE.Vector3(cx + dx * phi, cy + dy * phi, cz + dz * phi);
}


/**
 * subdivideOnSphere 将几何体细分后 投影在球面上
 * @param {Object} geometry threejs 几何对象
 * @param {float} r 球半径
 * @param {float} cx 球x坐标
 * @param {float} cy 球y坐标
 * @param {float} cz 球z坐标
 * @return {Object} geometry对象，投影后的几何体
 */
function subdivideOnSphere(geometry, r, cx, cy, cz) {
  var newPtMap = {};
  var faces = geometry.faces;
  var facesNew = [];
  var vertices = geometry.vertices;
  for (var i = faces.length - 1; i >= 0; i--) {
    var face = faces[i];
    //计算3个点
    var faceAIndex = face.a;
    var faceBIndex = face.b;
    var faceCIndex = face.c;
    var normal = face.normal;
    var color = face.color;
    var materialIndex = face.materialIndex;
    var ptA = vertices[faceAIndex];
    var ptB = vertices[faceBIndex];
    var ptC = vertices[faceCIndex];

    // var area = getAreaTriangle3d(ptA, ptB, ptC); //计算此三角形面积
    var ptABIndex, ptBCIndex, ptCAIndex;

    var ptABKey = min(faceAIndex, faceBIndex) + '_' + max(faceAIndex, faceBIndex);
    if (!newPtMap[ptABKey]) {
      var ptAB = new THREE.Vector3().addVectors(ptA, ptB).divideScalar(2);
      ptAB = projectPtOnSphere(ptAB, r, cx, cy, cz);
      ptABIndex = newPtMap[ptABKey] = vertices.length;
      vertices.push(ptAB);
    } else {
      ptABIndex = newPtMap[ptABKey];
    }

    var ptBCKey = min(faceBIndex, faceCIndex) + '_' + max(faceBIndex, faceCIndex);
    if (!newPtMap[ptBCKey]) {
      var ptBC = new THREE.Vector3().addVectors(ptB, ptC).divideScalar(2);
      ptBC = projectPtOnSphere(ptBC, cx, cy, cz, r);
      var ptBCIndex = newPtMap[ptBCKey] = vertices.length;
      vertices.push(ptBC);
    } else {
      ptBCIndex = newPtMap[ptBCKey];
    }
    
    var ptCAKey = min(faceAIndex, faceCIndex) + '_' + max(faceAIndex, faceCIndex);
    if (!newPtMap[ptCAKey]) {
    var ptCA = new THREE.Vector3().addVectors(ptC, ptA).divideScalar(2);
    ptCA = projectPtOnSphere(ptCA, cx, cy, cz, r);
    var ptCAIndex = newPtMap[ptCAKey] = vertices.length;
    vertices.push(ptCA);
    } else {
      ptCAIndex = newPtMap[ptCAKey];
    }

    //删除原先的face后 更新列表
    var face1 = new THREE.Face3(faceAIndex, ptABIndex, ptCAIndex, normal, color, materialIndex);
    var face2 = new THREE.Face3(ptABIndex, faceBIndex, ptBCIndex, normal, color, materialIndex);
    var face3 = new THREE.Face3(ptCAIndex, ptBCIndex, faceCIndex, normal, color, materialIndex);
    var face4 = new THREE.Face3(ptABIndex, ptBCIndex, ptCAIndex, normal, color, materialIndex);
    facesNew.push(face1);
    facesNew.push(face2);
    facesNew.push(face3);
    facesNew.push(face4);
  }
  geometry.vertices = vertices;
  geometry.faces = facesNew;
  geometry.computeFaceNormals();

  return geometry;
}

function laplacianVertices(vertices, verticeTopo){
  var newVerticles = [];
  for(var verticeIndex in vertices){
    var verticeObj = verticeTopo[verticeIndex];
    var bound = verticeObj.bound;
    if(bound){
      newVerticles.push(vertices[verticeIndex]);
    } else {
      var adj = verticeObj.adj;
      var pt = new THREE.Vector3(0,0,0);
      var n = 0;
      for(var idx in adj){
        var vertice = vertices[idx];
        pt.add(vertice);
        n++;
      }
      pt.divideScalar(n);
      newVerticles.push(pt);
    }
  }
  return newVerticles;
}


/**
 * laplacian 拉普拉斯光滑，让mesh变得更加平滑
 * @param {Object} geometry 几何对象
 * @return {Object} 几何对象
 */
function laplacian(geometry){//拉普拉斯光滑
  var faces = geometry.faces;
  var vertices = geometry.vertices;
  var verticeTopo = {};
  var lineMap = {};
  var adj;
  for(var index = 0; index<faces.length; index++){
    var face = faces[index];
    var pa = face.a, pb = face.b, pc = face.c;
    if(!verticeTopo[pa]){
      verticeTopo[pa] = {adj:{}};
    }
    adj = verticeTopo[pa].adj;
    adj[pb] = 1;
    adj[pc] = 1;

    if(!verticeTopo[pb]){
      verticeTopo[pb] = {adj:{}};
    }  
    adj = verticeTopo[pa].adj;
    adj[pa] = 1;
    adj[pc] = 1;

    if(!verticeTopo[pc]){
      verticeTopo[pc] = {adj:{}};
    } 
    adj = verticeTopo[pa].adj;
    adj[pa] = 1;
    adj[pb] = 1;

    var lineABKey = min(pa, pb) + '_' + max(pa, pb);
    var lineBCKey = min(pb, pc) + '_' + max(pb, pc);
    var lineCAKey = min(pc, pa) + '_' + max(pc, pa);

    if(lineMap[lineABKey]){
      delete lineMap[lineABKey];
    }else{
      lineMap[lineABKey] = 1;
    }
    if(lineMap[lineBCKey]){
      delete lineMap[lineBCKey];
    }else{
      lineMap[lineBCKey] = 1;
    }
    if(lineMap[lineCAKey]){
      delete lineMap[lineCAKey];
    }else{
      lineMap[lineCAKey] = 1;
    }
  }

  for(var key in lineMap){
    var keySplit = key.split('_');
    var from = keySplit[0];
    var to = keySplit[1];
    verticeTopo[from].bound = 1;
    verticeTopo[to].bound = 1;
  }

  for(var k = 0; k< 15; k++){
    vertices = laplacianVertices(vertices, verticeTopo);
  }
  
  geometry.vertices = vertices;
  geometry.computeFaceNormals();

  return geometry;
}
/**
 * genSphereParticles 生成一堆半径为 r0 +- dr 的随机点
 * @param  {Float} r0  主半径
 * @param  {Float} dr 浮动
 * @param  {Integer} n 个数
 * @return {Object}  THREE.Geometry对象
 */
function genSphereParticles(r0, dr, n) {
  var geometry = new THREE.Geometry();
  var vertices = geometry.vertices;
  for (var i = n - 1; i>=0; i--){
    var r = r0 + sin(1000*i)*dr;
    var theta = PI * random();
    var phi = PI * 2 * random();
    var x = r * sin(theta) * cos(phi);
    var y = r * sin(phi);
    var z = r * cos(theta) * cos(phi);
    vertices.push(new THREE.Vector3(x, y, z));
  }
  return geometry;
}

/**
 * detect 检查是否支持webgl
 */
function detect() {
  try {
    var canvas = document.createElement('canvas');
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
      throw '您的浏览器不支持webgl';
    }
  } catch (e) {
    alert('您的浏览器不支持webgl');
  }
}

detect();

module.exports = $.extend(Utils, {
  'genSphereParticles': genSphereParticles,
  'getAreaTriangle3d': getAreaTriangle3d,
  'subdivideOnSphere': subdivideOnSphere,
  'laplacian': laplacian,
  'getLatlngSphere': getLatlngSphere,
  'mercator': mercator,
  'sphere': sphere,
  'getPt': getPt,
  'detect': detect
});
