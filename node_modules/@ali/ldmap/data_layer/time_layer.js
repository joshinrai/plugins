'use strict';
var eventEmitter = require('bcore/event');
var Stream = require('@ali/stream');
var Util = require('./../core/utils');
var Animator = require('./../core/animator');

/**
 * TimeLayer 飞线等数据管理
 * @class  TimeLayer
 */
function TimeLayer(opt) {
  this.initialize(opt);
}

TimeLayer = Animator.extend(TimeLayer, {
  'lifeMin': null,
  'lifeMax': null,
  'life': null,
  'lifeSpeed': 10000,
  'isLifeByNow': false,
  'isNeedSort': true,
  'isOverlap': true,
  'isLoop': true,
  initialize: function (opt) { 
    Util.merge(this, opt);
  },
  'getNow': function () {
    return new Date().getTime();
  },
  'maxLoopN': 30, //一次update 最多触发几条visulizer
  'dataIndex': 0,
  '_hideVisuals': [],
  'isAutoStart': false,
  'getTime': function (d) {
    return d.time || d.t;
  },
  'visualize': null,
  'addEvents': function () {},

  /**
   * addEventsVisual 为可视图元加上hide事件 如果隐藏消失 可以放入回收队列
   * @param  visual 
   */
  addEventsVisual: function (visual) { //为visual组元添加事件
    var self = this;
    if (visual.hide) {
      try {
        visual.removeListener('hide');
      } catch (e) {}
      try {
        visual.removeEventListener('hide');
      } catch (e) {}
      visual.on('hide', function () { //当元素完全隐藏的时候 触发回收机制
        return self._hideVisuals.push(visual);
      });
    }
  },

  'data': function (ds) {
    var d, t, getTime = this.getTime;
    var lifeMin = null, lifeMax = null;

    if (this.isOverlap) this._datas = [];
    var datas = this._datas;

    for (var i in ds) {
      d = ds[i];
      //检查时间参数
      t = getTime(d);
      t = Date.parse(t);
      if (!t) continue; //遇到某行时间错误 则跳过
      d.timeFormat = t;
      lifeMin = lifeMin || t;
      if (lifeMin > t) lifeMin = t;
      lifeMax = lifeMax || t;
      if (lifeMax < t) lifeMax = t;
      datas.push(d);
    }

    this.lifeMin = lifeMin;
    this.lifeMax = lifeMax;
    this.life = this.lifeMin;
    this._datas = datas;
    if (this.isNeedSort) this.sort();
    this.startAnim();
  },

  /**
   * sort 所有数据按照时间排序
   */
  'sort': function () {
    var getTime = this.getTime;
    this._datas.sort(function (a, b) {
      return  a.timeFormat - b.timeFormat;
    });
  },

  /**
   * 更新 
   */
  '_updateLife': function () {
    var timeFormat, time = this.life, datas = this._datas, d, maxLoop = 0;
    var maxLoopN = this.maxLoopN;
    var lifeSpeed;
    if (this.isLifeByNow) {
      var nowP = this.nowP = this.now || this.getNow();
      var now = this.now = this.getNow();
      if(now - nowP === 0) return;
      this.life = nowP;
      lifeSpeed = now - nowP;
    } else {
      lifeSpeed = this.lifeSpeed;
    }
    // console.log(this.getNow(), this.life);
    for(var i = 0; i < maxLoopN; i++){
      if (this.dataIndex > datas.length - 1) return this._onLifeEnd(); //如果数组越界, 则循环结束
      d = datas[this.dataIndex];
      timeFormat = d.timeFormat;
      if(timeFormat < (this.life + lifeSpeed)){
        this._onData(d);
        this.dataIndex++;
        time = timeFormat;
      } else { //已经超过了这次的范围
        return this.life+= lifeSpeed;
      }
    }
    this.life = time;
    if(this.life >= this.lifeMax) this._onLifeEnd();
  },
  '_onData': function (d) {
    var visual, visualize = this.visualize;
    var hideVisuals = this._hideVisuals;
    if (hideVisuals.length) {
      visual = hideVisuals.pop();
    } else {
      visual = (typeof(visualize) === 'object') ? visualize : visualize();
      this.addEventsVisual(visual);
    }
    visual.data(d);
  },
  'reset': function () {
    this.lifeMin = null;
    this.lifeMax = null;
    this.life = null;
    this.dataIndex = 0;
  },
  'restart': function () {
    this.life = this.lifeMin;
    this.resume();
    this.dataIndex = 0;
  },
  'resume': function () {
    if (this.isLifeByNow) this.nowP = this.getNow();
    if(this.isLooping) return;
    this.isLooping = true;
    this.loop();
  }
});

TimeLayer.prototype.broadCast = TimeLayer.prototype.loop;

module.exports = TimeLayer;