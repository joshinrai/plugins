'use strict';

/**
 * ` 获取geojson Feature元素的boundingbox
 * @param {Object} feature
 * @return {Array} boundingbox
 */
function getFeatureBBox (feature) {
  var geo = feature.geometry;
  var type = geo.type;
  var latMin, latMax, lngMin, lngMax;
  var arr, ar, latlng, lat, lng;
  if (type === 'Polygon') {
    arr = geo.coordinates;
    latMin = latMax = arr[0][0][0];
    lngMin = lngMax = arr[0][0][1];

    for (var i in arr) {
      ar = arr[i];
      for (var k in ar) {
        latlng = ar[k];
        lat = latlng[0];
        lng = latlng[1];
        latMin = (latMin > lat) ? lat : latMin;
        lngMin = (lngMin > lng) ? lng : lngMin;
        latMax = (latMax < lat) ? lat : latMax;
        lngMax = (lngMax < lng) ? lng : lngMax;
      }
    }
    return [
      [lngMin, latMin],
      [lngMax, latMax]
    ];
  } else if (type === 'MultiPolygon') {
    var arrs = geo.coordinates;
    latMin = latMax = arrs[0][0][0][0];
    lngMin = lngMax = arrs[0][0][0][1];
    for (var j in arrs) {
      arr = arrs[j];
      for (var l in arr) {
        ar = arr[l];
        for (var m in ar) {
          latlng = ar[m];
          lat = latlng[0];
          lng = latlng[1];
          latMin = (latMin > lat) ? lat : latMin;
          lngMin = (lngMin > lng) ? lng : lngMin;
          latMax = (latMax < lat) ? lat : latMax;
          lngMax = (lngMax < lng) ? lng : lngMax;
        }
      }
    }
    return [
      [lngMin, latMin],
      [lngMax, latMax]
    ];
  } else {
    return;
  }
}


/**
 * getIndex 判断点在多边形内外的方法中，用到的一个判断函数
 * @param {Float} x
 * @param {Float} y
 * @return {Integer}
 */
function getIndex(x, y) {
  if (y > 0) {
    if (x > 0) {
      return 1;
    } else {
      return 2;
    }
  } else {
    if (x < 0) {
      return 3;
    } else {
      return 4;
    }
  }
}


/**
 * isPtInPolygon 一个点是否在一个多边形的内部
 * @param {Object} pt 需要判断的点
 * @param {Object} polygon 多边形
 * @return {Boolean}
 */
function isPtInPolygon(pt, polygon) {
  var count = 0;
  var length = polygon.length;
  for (var i = 0; i < length; i++) {
    var ptA = polygon[i];
    var ptB = polygon[(i + 1) % length];

    var dAX = ptA[0] - pt.lng;
    var dAY = ptA[1] - pt.lat;
    var dBX = ptB[0] - pt.lng;
    var dBY = ptB[1] - pt.lat;

    var delta = getIndex(dBX, dBY) - getIndex(dAX, dAY);
    if (delta === 1 || delta === -3) {
      count += 1;
    }
    if (delta === -1 || delta === 3) {
      count -= 1;
    }
    if (delta === 2 || delta === -2) {
      var product = dBY * dAX - dBX * dAY;
      if (product > 0) {
        count += 2;
      } else {
        count -= 2;
      }
    }
  }
  return (Math.abs(count) === 4) ? true : false;
}

/**
 * isPtInPolygons 判断点是否在多个多边形内
 * @param {Object} pt 参与判断的polygon组
 * @param {Object} polygons 多个多边形内
 * @return {Boolean}
 */
function isPtInPolygons(pt, polygons) {
  for (var k = 0; k < polygons.length; k++) {
    //如果多边形的形式为multipolygon
    if (polygons[k] && polygons[k][0] && polygons[k][0][0] && polygons[k][0][0][0]) {
      if (isPtInPolygon(pt, polygons[k][0])) {
        return true;
      }
    } else {
      if (isPtInPolygon(pt, polygons[k])) {
        return true;
      }
    }
  }
  return false;
}

/**
 * simplyfys 简化多边形点数，让点在多边形内外判断效率更高
 * @param {Object} polygons 需要简化的多边形
 * @param {Integer} maxN 一条线最多的点数
 * @return {Object} 简化后的多边形
 */
function simplyfys(polygons, maxN) {
  var result = [];
  for (var k = 0; k < polygons.length; k++) {
    var polygon = polygons[k];
    var length = polygon.length;
    var arr = [];
    var distance = parseInt(Math.round(length / maxN), 10);
    if (distance === 0) {
      distance = 1;
    }
    for (var i = 0; i < length; i += distance) {
      arr.push(polygon[i]);
    }
    result.push(arr);
  }
  return result;
}

/**
 * isPtInBound 判断一个点是否在方形区域内（如果判断点是否在边界内，首先判断是否在bbox内，如此更快）
 * @param {Object} pt 需要判断的点
 * @param {Array} bounds boundingbox
 * @return {Boolean}
 */
function isPtInBound(pt, bounds) {
  var min = bounds[0];
  var max = bounds[1];
  if (pt[0] < min[1]) return false;
  if (pt[0] > max[1]) return false;
  if (pt[1] < min[0]) return false;
  if (pt[1] > max[0]) return false;
  return true;
}

/**
 * divideby 让一个数按照一个区间切分取整
 * @param {Float} num
 * @param {Float} k
 * @return {Float}
 */
function divideby(num, k){
  return Math.round(num / k) * k;
}

function gridfy(obj, xk, yk){
  if(!xk) {return obj;}
  yk = yk || xk;
  obj.lat = divideby(obj.lat, xk);
  obj.lng = divideby(obj.lng, yk);
  return obj;
}

/**
 * genIsPolygonInFeature 返回判断函数：判断一点是否在指定的geojson内部 通过在一张空白的canvas上画上地图 判断像素的alpha值是否大于0
 * @param  {Object}  feature Geojson的一个子元素
 * @param  {Object}  opt     配置
 */
function genIsPolygonInFeature(feature, opt){
  opt = opt || {};
  var bbox = opt.bbox || getFeatureBBox(feature);
  var latMin = bbox[0][0];
  var lngMin = bbox[0][1];
  var latMax = bbox[1][0];
  var lngMax = bbox[1][1];
  var dLat = latMax - latMin;
  var dLng = lngMax - lngMin;

  var geometry = feature.geometry;
  var coordinates = geometry.coordinates;
  var type = geometry.type;

  var scale = opt.scale || 500;
  var transfer = function(lat, lng) {
    return {
      x: Math.floor((latMax - lat) / dLat * scale),
      y: Math.floor((lngMax - lng) / dLng * scale)
    };
  };

  var canvas = document.createElement('canvas');
  canvas.width = canvas.height = scale;
  var ctx = canvas.getContext('2d');
  ctx.fillStyle = '#000';

  if (type.toLowerCase() === 'polygon') {
    for (var k in coordinates) {
      var pathArr = coordinates[k];
      for (var i in pathArr) {
         i = parseInt(i);
        var latlng = pathArr[i];
        var pt = transfer(latlng[1], latlng[0]);
        if (i === 0) {
          ctx.beginPath();
          ctx.moveTo(pt.x, pt.y);
        } else {
          ctx.lineTo(pt.x, pt.y);
        }
        if (i === (pathArr.length - 1)) {
          ctx.fill();
          ctx.closePath();
        }
      }
    }
  }

  if (type.toLowerCase() === 'multipolygon') {
    for (var k in coordinates) {
      var coordinate = coordinates[k];
      for (var j in coordinate) {
        var pathArr = coordinate[j];
        for (var i in pathArr) {
          i = parseInt(i);
          var latlng = pathArr[i];
          var pt = transfer(latlng[1], latlng[0]);
          if (i === 0) {
            ctx.beginPath();
            ctx.moveTo(pt.x, pt.y);
          } else {
            ctx.lineTo(pt.x, pt.y);
          }
          if (i === (pathArr.length - 1)) {
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }
  }
  var data = ctx.getImageData(0, 0, scale, scale).data;
  return function (pt) {
    var p = transfer(pt.lat, pt.lng);
    var index = p.x + scale * p.y;
    return  (data[index * 4 - 1] > 0) ;
  };
}

function randomPick(list) {//随机选择数据
  return list[Math.floor(Math.random() * list.length)];
}

module.exports = {
  'genIsPolygonInFeature': genIsPolygonInFeature,
  'getFeatureBBox': getFeatureBBox,
  'isPtInPolygons': isPtInPolygons,
  'isPtInBound': isPtInBound,
  'randomPick': randomPick,
  'simplyfys': simplyfys,
  'divideby': divideby,
  'gridfy': gridfy
};
