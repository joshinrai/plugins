'use strict';
var Color = require('./../color');
var EventEmitter = require('bcore/event');
var Utils = require('bcore/utils');
var deepMerge = Utils.deepMerge;

var blending = Color.blending;
var getColorFunc = Color.getColorFunc;

function upper(str){
  return str[0].toUpperCase() + str.slice(1);
}

function clean(ctx) {
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
}

function Gradient(ctx, options) {
  this.ctx = ctx;
  this.initialize(ctx, options);
}

Gradient = EventEmitter.extend(Gradient, {
  options:{
    type: 'radian',
    drawN: 6,
    isContinue: false
  },
  initialize: function (ctx, options) {
    this.options = Utils.deepMerge(this.options, options);
    this.updateColor(options.color);
    this.updateSprite();
  },
  update: function (ds) {
    var bol = false;
    for(var key in ds){
      if(ds[key] === undefined || ds[key] === null) continue;
      if(this.options[key] !== ds[key]){
        bol = true;
        if(this['update' + upper(key)]){
          this['update' + upper(key)](ds[key]);
        }else{
          this.options[key] = ds[key];
        }
      }
    }
    if(bol) return this.updateSprite();
  },
  updateType: function (type) {
    this.options.type = type;
  },
  updateColor: function (a, b, c) {
    this.colorFunc = getColorFunc(a, b, c);
  },
  updateDrawN: function (drawN){
    this.options.drawN = drawN;
  },
  updateSprite: function() {
    clean(this.ctx);
    var type = this.options.type;
    var isContinue = this.options.isContinue;
    if (type === 'linear' && !isContinue) return this.updateSpriteLinear();
    if (type === 'linear' && isContinue) return this.updateSpriteLinearContinue();
    if (type === 'radian' && !isContinue) return this.updateSpriteRadian();
    if (type === 'radian' && isContinue) return this.updateSpriteRadianContinue();
    this.emit('update');
  },

  updateSpriteLinear: function() {
    var colorFunc = this.colorFunc;
    var ctx = this.ctx,
      w = ctx.canvas.width,
      h;
    ctx.globalCompositeOperation = 'source-over';
    var d = 1 / this.options.drawN;
    for (var k = 0; k < 1; k += d) {
      ctx.fillStyle = colorFunc(k);
      h = w * k;
      ctx.fillRect(h, 0, d * w, w);
      ctx.fill();
    }
  },

  updateSpriteRadian: function() {
    var colorFunc = this.colorFunc;
    var ctx = this.ctx;
    var w = ctx.canvas.width,
      h;
    var d = 1 / this.options.drawN;
    var r = w/2;
    for (var k = 1; k > 0; k -= d) {
      ctx.beginPath();
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = colorFunc(k);
      ctx.arc(r, r, r * k, 0, Math.PI*2);
      ctx.fill();
      ctx.closePath();
      ctx.beginPath();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillStyle = '#000';
      ctx.arc(r, r, r * Math.max((k - d), 0), 0, Math.PI*2);
      ctx.fill();
      ctx.closePath();
    }
  },

  updateSpriteLinearContinue: function(){
    var colorFunc = this.colorFunc;
    var ctx = this.ctx;
    ctx.globalCompositeOperation = 'source-over';
    var w = ctx.canvas.width;
    var gradient = ctx.createLinearGradient(0,0,w,0);
    for(var k = 0; k <= 1; k+= 1/ this.drawN){
      k = Math.round(k*100) / 100;
      gradient.addColorStop(k, colorFunc(k));
    }
    ctx.fillStyle = gradient;
    ctx.fillRect(0,0,w,w);
  },

  updateSpriteRadianContinue: function(){
    var colorFunc = this.colorFunc;
    var ctx = this.ctx;
    ctx.globalCompositeOperation = 'source-over';
    var w = ctx.canvas.width;
    var r = w / 2;
    var gradient = ctx.createRadialGradient(r,r,0,r,r,r);
    for(var k = 0; k <= 1; k+= 1/ this.drawN){
      gradient.addColorStop(k, colorFunc(k));
    }
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0,0,w,w);
  },
  
  getBase64: function() {
    return this.ctx.canvas.toDataURL();
  },
  getCanvas: function() {
    return this.ctx.canvas;
  }
});

function gradient(ctx, opt) {
  return new Gradient(ctx, opt);
}

module.exports = gradient;