'use strict';
 var geohash = require('ngeohash');
 var map = require('./map');
 var Utils = require('bcore/utils');
 var L = require('leaflet');

function Grid() {
}

Grid.prototype = {
  shapeType: 'hex',
  _r: 10,
  _rx: null,
  _ry: null,
  _precision: 5, //经纬度的精度 一般5位已经很精确了
  transform: function (transform) {
    if(!transform) return;
    this._transform = transform;
    this.update();
    return this;
  },

  r: function (r) {
    if (this._r === r) return;
    this._r = this._rx = this._ry = r;
    return this;
  },
  rx: function (rx) {
    if (this._rx === rx) return;
    this._rx = rx;
    return this;
  },
  ry: function (ry) {
    if (this._ry === ry) return;
    this._ry = ry;
    return this;
  },

  /**
   * shape 规定grid的类型
   * @param  {String | } type [description]
   * @return {[type]}      [description]
   */
  shape: function (type) {
    if (!type) return;
    if (typeof (type) === 'number') {
      if (type === 4) {
        type = 'rect';
      } else if (type === 6) {
        type = 'hex';
      } else {
        return console.log('目前只支持六边形和方形 数字只能为4和6');
      }
    }
    if (type !== 'rect' && type !== 'hex') {
      return console.log('目前只支持六边形和方形 数字只能为4和6');
    }
    this.shapeType = type;
    return this;
  },

  update: function () {
    if (!this._transform) return console.log('必须设定屏幕距离与经纬度的转换 transform');
    var d = this._transform(this._rx || this._r, this._ry || this._r);
    var precision = this._precision;
    this.dlat = (d.dlat).toPrecision(precision);
    this.dlng = (d.dlng).toPrecision(precision);
    return this;
  },

  // 将grid-hash编码
  encode: function (lat, lng) {
    var dlat = this.dlat, dlng = this.dlng;
    var shapeType = this.shapeType;
    if (shapeType === 'rect') return this.encodeRect(lat, lng, dlat, dlng);
    if (shapeType === 'hex') return this.encodeHex(lat, lng, dlat, dlng);
  },


  //将grid-hash解码
  decode: function (key) {
    var ks = key.split('_');
    var shapeType = ks[0];
    var latkey = parseInt(ks[1], 10), lngkey = parseInt(ks[2], 10), dlat = parseFloat(ks[3]), dlng = parseFloat(ks[4]);
    var latMin = (latkey - 0.5) * dlat,
        lngMin = (lngkey - 0.5) * dlng,
        latMax = (latkey + 0.5) * dlat,
        lngMax = (lngkey + 0.5) * dlng;
    if (shapeType === 'rect') return this.toPtsRect(latMin, lngMin, latMax, lngMax);
    if (shapeType === 'hex'){
      var isOdd = latkey % 2;
      return this.toPtsHex(latMin, lngMin, latMax, lngMax, isOdd);
    } 
  },

  encodeRect: function (lat, lng, dlat, dlng) {
    var latkey = Math.floor(lat / dlat + 0.5) || 0, lngkey = Math.floor(lng / dlng + 0.5) || 0;
    return this.shapeType + '_' + latkey + '_' + lngkey + '_' + dlat + '_' + dlng;
  },

  toPtsRect: function (latMin, lngMin, latMax, lngMax) {
    return {
      pts: [[latMin, lngMin], [latMax, lngMin], [latMax, lngMax], [latMin, lngMax]],
      center: [(latMin + latMin) / 2, (lngMin + lngMax) / 2]
    };
  },

    // var latkey = Math.floor (lat / dlat + 0.5);
    // var isOdd = latkey % 2;
    // var lngkey = Math.floor(lng / dlng + 0.5 - isOdd * 0.5);
    // return this.shapeType + '_' + latkey + '_' + lngkey + '_' + dlat + '_' + dlng;

  /**
   * encodeHex 对六边形的情况进行编码
   * @param  {Number} lat  输入经度
   * @param  {Number} lng  输入纬度
   * @param  {Number} dlat 格子的经度差
   * @param  {Number} dlng 格子的纬度差
   * @return {String}      格子的哈希
   */
  encodeHex: function (lat, lng, dlat, dlng) {
    // var latkey = Math.floor (lat / dlat + 0.5);
    // var isOdd = latkey % 2;
    // var lngkey = Math.floor(lng / dlng + 0.5 - isOdd * 0.5);
    // return this.shapeType + '_' + latkey + '_' + lngkey + '_' + dlat + '_' + dlng;
    //
    var latkey = lat / dlat + 0.5;
    var latkeyFloor = Math.floor(latkey);
    var isOdd = latkeyFloor % 2;
    var lngkey = lng / dlng + 0.5 - isOdd * 0.5;
    var lngkeyFloor = Math.floor(lngkey);
    //
    var latkeyMore = latkey % 1;
    var lngkeyMore = lngkey % 1;
    if(latkeyMore > 2 / 3){
      var dx = lngkeyMore - 0.5;
      var dy = latkeyMore - 2 / 3;
      var add = 0;
      if(dx > 0 && 3 * dy + dx > 0){
        lngkey = lngkeyFloor;
        latkey = latkeyFloor + 1;
      } else {
       latkey = latkeyFloor;
       lngkey = lngkeyFloor;       
      }
    } else {
      latkey = latkeyFloor;
      lngkey = lngkeyFloor;
    }
    return this.shapeType + '_' + latkey + '_' + lngkey + '_' + dlat + '_' + dlng;
  },

  toPtsHex: function (latMin, lngMin, latMax, lngMax, isOdd) {
    var cx = (lngMin + lngMax) / 2, cy = (latMax + latMin) / 2;
    var rx = (lngMax - lngMin) / 2, ry = (latMax - latMin) / 2;
    cx += rx * isOdd;
    var p1x = cx, p1y = cy + ry;
    var p2x = cx + rx, p2y = cy + ry * 2 / 3;
    var p3x = p2x, p3y = cy - ry;
    var p4x = cx, p4y = cy - ry * 4 / 3;
    var p5x = cx - rx, p5y = p3y;
    var p6x = p5x, p6y = p2y;
    return {
      center: [cy, cx],
      pts: [[p1y, p1x], [p2y, p2x], [p3y, p3x], [p4y, p4x], [p5y, p5x], [p6y, p6x]]
    };
  }
};

module.exports = Grid;
