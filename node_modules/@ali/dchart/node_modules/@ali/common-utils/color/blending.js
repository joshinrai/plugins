'use strict';
var format = require('./format');
var transition = require('./../transition');
var parse = format.parse;
var toString = format.toString;
var rgb2hsl = format.rgb2hsl;
var Easing = require('./../easing');
var pow = Math.pow,
  max = Math.max,
  min = Math.min;

function lerp(colorFrom, colorTo, k) {
  var from = parse(colorFrom),
    to = parse(colorTo);

  k = min(k, 1);
  k = max(k, 0);

  var type = from.type;
  var arrF = from.arr,
    arrT = to.arr;
  var l = arrF[0],
    dl = arrT[0] - l;
  var ll = arrF[1],
    dll = arrT[1] - ll;
  var lll = arrF[2],
    dlll = arrT[2] - lll;
  var llll = arrF[3],
    dllll = arrT[3] - llll;

  return toString({
    type: type,
    arr: [
      l + dl * k,
      ll + dll * k,
      lll + dlll * k,
      llll + dllll * k,
    ]
  });
}

function Blending (colorFrom, colorTo, blendingType, easing){
  if(typeof(blendingType) === 'number') return lerp(colorFrom, colorTo, blendingType);
  var blendingType = blendingType || 'hsl';
  var from = parse(colorFrom),
    to = parse(colorTo);
  if (blendingType.indexOf('hsl') !== -1) {
    if (from.type.indexOf('hsl') === -1) from = rgb2hsl(from);
    if (to.type.indexOf('hsl') === -1) to = rgb2hsl(to);
  }
  if (!from || !to) return;
  var type = from.type;

  var arrF = from.arr,
    arrT = to.arr;
  var l = arrF[0],
    dl = arrT[0] - l;
  var ll = arrF[1],
    dll = arrT[1] - ll;
  var lll = arrF[2],
    dlll = arrT[2] - lll;
  var llll = arrF[3],
    dllll = arrT[3] - llll;

  if (from.type !== to.type) return console.log('colorFrom和colorTo的类型应该一致');
  var easing = transition().easing(easing || 'linear').toFunc();

  this.func = function(k) {
    k = easing(k);
    return toString({
      type: type,
      arr: [
        l + dl * k,
        ll + dll * k,
        lll + dlll * k,
        llll + dllll * k
      ]
    });
  };

  return this;
} 

Blending.prototype.toFunc = function() {
  return this.func;
};

Blending.prototype.toArray = function(N) {
  var func = this.func, arr = [];
  for(var k = 1; k>=0; k-= 1/N){
    arr.push(func(k));
  }
  return arr;
};

/**
 * toCss 生成渐变的css
 * @param  {Number} N   细分的段数
 * @param  {Object} opt 参数对象
 * @return {Object}     返回css对象{background:xxxx}
 */
Blending.prototype.toCss = function(N, opt) {//radial
  var N = N || 5;
  var opt = opt || {};
  var type = opt.type || 'linear';
  var func = this.func, arr = [];
  var arr = [], arr1 = [];
  for(var k = 0; k<=1; k+= 1/N){
    arr.push('color-stop(' + k.toFixed(2) + ',' + func(k) + ') ');
    arr1.push(func(k));
  }
  var str = arr.join(','), str1 = arr1.join(',');
  //
  var gradient, webkitGradient;
  if(type === 'linear'){
    var direction = opt.direction || 'left top, left bottom,';
    gradient = 'gradient(linear,' + direction + str + ')';
    webkitGradient = '-webkit-gradient(linear,' + str + ')';
  } else {
    var center = opt.center || 'center';
    gradient = 'radial-gradient(' + center + ', ellipse,' + str1 + ')'
    webkitGradient = '-webkit-radial-gradient(' + center + ', ellipse,' + str1 + ')'
  }
  return {
    'background': gradient,
    'backgroundImage': webkitGradient
  };
};

function blending(colorFrom, colorTo, blendingType, easing){
  return new Blending(colorFrom, colorTo, blendingType, easing);
}

// console.log(parseColor('#0ff'),parseColor('#00ffff'),parseColor('rgb(0,255,255)'),parseColor('rgba(0,255,255,1)'),parseColor('hsl(180,100%,50%)'),parseColor('hsla(180,100%, 50%, 0.5)'));
module.exports = blending;

