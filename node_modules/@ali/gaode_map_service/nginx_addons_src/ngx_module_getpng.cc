// Copyright (c) 2012 AutoNavi Inc.
// Author: 蔡荣 <rong.cai@autonavi.com>

//================================================================
// C++取图服务，只针对汇聚图源。
// 汇聚图包括两类数据：idx和dat。
// tile数据是直接按照格子grid大小，以及自身的xy值，compat到dat文件中
// 因此每个tile在dat中都有一个偏移量，
// idx中在每个tile的xy值对应的位置记录了该偏移量。
// 因此读取tile的过程包括：读idx获取offset（新版idx文件还可以获取到datalen信息），
// 再读dat获取到datalen，再返回tile数据。
// tile的数据格式由配置文件中的“format”指定，如果不指定则为“png”。
// 通过alias或root指定汇聚数据的位置。
// 对数据的要求就是必须是汇聚格式，并且必须有404.png这张图片。
// 对于栅格图，还必须有land/grass/water.png。

// 参考baidu的方案，不管有什么异常都吐404。
//================================================================

extern "C" {
#include <ngx_config.h>
#include <ngx_core.h>
#include <ngx_http.h>
}

#include <errno.h>
#include <assert.h>

#include <string>

using std::string;

static char* ngx_http_getpng(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
static void* ngx_http_getpng_create_loc_conf(ngx_conf_t *cf);
static char* ngx_http_getpng_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child);

// tile汇聚是格子大小
static const int32_t kGridSize = 128;
// 汇聚时分目录阈值
static const int32_t kMaxDirSize = 10;
static const int32_t kBaseIdxFileSize = kGridSize * kGridSize;

char log_buffer[1000];


enum {
  kLandPng = -1,
  kWaterPng = -2,
  kGrassPng = -3,
  kDefaultPng = -100,
  kBad404Png = -404,
};

typedef struct {
  ngx_str_t format;
} ngx_http_getpng_loc_conf_t;

enum TileIndexInfoVersion {
  V0 = 0,   // int idx
  V1,       // long idx
};

#pragma pack(1)
// 旧版本V0的tileIndex信息只包含offset
typedef struct {
  int32_t offset;
} TileIndexInfoV0;

// 新版本V1的tileIndex信息包含offset
typedef struct {
  int64_t offset;
} TileIndexInfoV1;
#pragma pack(0)

// Take from tokyo cabinet
#define TCSWAB32(TC_num) \
  ( \
    ((TC_num & 0x000000ffUL) << 24) | \
    ((TC_num & 0x0000ff00UL) << 8) | \
    ((TC_num & 0x00ff0000UL) >> 8) | \
    ((TC_num & 0xff000000UL) >> 24) \
  )

#define TCSWAB64(TC_num) \
  ( \
    ((TC_num & 0x00000000000000ffULL) << 56) | \
    ((TC_num & 0x000000000000ff00ULL) << 40) | \
    ((TC_num & 0x0000000000ff0000ULL) << 24) | \
    ((TC_num & 0x00000000ff000000ULL) << 8) | \
    ((TC_num & 0x000000ff00000000ULL) >> 8) | \
    ((TC_num & 0x0000ff0000000000ULL) >> 24) | \
    ((TC_num & 0x00ff000000000000ULL) >> 40) | \
    ((TC_num & 0xff00000000000000ULL) >> 56) \
  )

static ngx_command_t ngx_http_getpng_commands[] = {
  {
    ngx_string("merge"),
    NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,
    ngx_http_getpng,
    0,
    0,
    NULL
  },
  {
    ngx_string("format"),
    NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
    ngx_conf_set_str_slot,
    NGX_HTTP_LOC_CONF_OFFSET,
    offsetof(ngx_http_getpng_loc_conf_t, format),
    NULL
  },

  ngx_null_command
};


static ngx_http_module_t  ngx_http_getpng_module_ctx = {
  NULL,                          /* preconfiguration */
  NULL,                           /* postconfiguration */

  NULL,                          /* create main configuration */
  NULL,                          /* init main configuration */

  NULL,                          /* create server configuration */
  NULL,                          /* merge server configuration */

  ngx_http_getpng_create_loc_conf,      /* create location configuration */
  ngx_http_getpng_merge_loc_conf        /* merge location configuration */
};


ngx_module_t ngx_module_getpng = {
  NGX_MODULE_V1,
  &ngx_http_getpng_module_ctx, /* module context */
  ngx_http_getpng_commands,   /* module directives */
  NGX_HTTP_MODULE,               /* module type */
  NULL,                          /* init master */
  NULL,                          /* init module */
  NULL,                          /* init process */
  NULL,                          /* init thread */
  NULL,                          /* exit thread */
  NULL,                          /* exit process */
  NULL,                          /* exit master */
  NGX_MODULE_V1_PADDING
};

// 提取出url参数中的xyz部分
static ngx_int_t ParseArgs(ngx_http_request_t *r, 
		int32_t *x, int32_t *y, int32_t *z, int8_t *c) {
  ngx_str_t value;
  off_t x_, y_, z_, c_;
  if (ngx_http_arg(r, (u_char *)"x", 1, &value) == NGX_OK) {
    x_ = ngx_atoof(value.data, value.len);
    if (x_ == NGX_ERROR) {
      return -1;
    }
  } else {
    return -1;
  }

  if (ngx_http_arg(r, (u_char *)"y", 1, &value) == NGX_OK) {
    y_ = ngx_atoof(value.data, value.len);
    if (y_ == NGX_ERROR) {
      return -1;
    }
  } else {
    return -1;
  }

  if (ngx_http_arg(r, (u_char *)"z", 1, &value) == NGX_OK) {
    z_ = ngx_atoof(value.data, value.len);
    if (z_ == NGX_ERROR) {
      return -1;
    }
  } else {
    return -1;
  }
  
  if (ngx_http_arg(r, (u_char *)"c", 1, &value) == NGX_OK) {
    c_ = ngx_atoof(value.data, value.len);
    if (c_ == NGX_ERROR) {
      return -1;
    }
  } else {
    return -1;
  }

  *x = x_;
  *y = y_;
  *z = z_;
  *c = c_;

  return 0;
}

// 根据xyz计算出对应的idx和dat文件名
/**
static void GetIdxAndDatFileName(ngx_http_request_t *r,
                                 int32_t x, int32_t y, int32_t z,
                                 string *idx_filename,
                                 string *dat_filename) {
  int32_t gx = x / kGridSize;
  int32_t gy = y / kGridSize;
  int32_t dx = gx / kMaxDirSize;
  int32_t dy = gy / kMaxDirSize;

  // 生成数据存放目录
  char grid_name[256];
  snprintf(grid_name, sizeof(grid_name),
           "/%d/%d/%d/%d_%d_%d", z, dx, dy, z, gx, gy);

  // 从alias中取出路径
  ngx_http_core_loc_conf_t *clcf =
    (ngx_http_core_loc_conf_t *)ngx_http_get_module_loc_conf(r, ngx_http_core_module);

  // 拼装IDX和DAT文件名
  dat_filename->assign((char *)clcf->root.data, clcf->root.len);
  dat_filename->append(grid_name);
  dat_filename->append(".dat");

  idx_filename->assign((char *)clcf->root.data, clcf->root.len);
  idx_filename->append(grid_name);
  idx_filename->append(".idx");
}
*/
// 根据xyz计算出对应的idx和dat文件名
static void GetIdxAndDatFileName(ngx_http_request_t *r,
                                 int32_t x, int32_t y, int32_t z,
								 int8_t c,
                                 string *idx_filename,
                                 string *dat_filename) {
  int32_t gx = x / kGridSize;
  int32_t gy = y / kGridSize;
  int32_t dx = gx / kMaxDirSize;
  int32_t dy = gy / kMaxDirSize;
	
  string tile_type;
  if(c==1){
	tile_type = "poi";
  }else if(c==2){
	tile_type = "roadlabel";
  }else if(c==4){
	tile_type = "road";
  }else if(c==8){
	tile_type = "region";
  }else if(c==16){
	tile_type = "poi";
  }else{
	tile_type = "region"; 
  }

  // 生成数据存放目录
  char grid_name[256];
  snprintf(grid_name, sizeof(grid_name),
           "/%s/%d/%d/%d/%d_%d_%d", tile_type.c_str(), z, dx, dy, z, gx, gy);

  // 从alias中取出路径
  ngx_http_core_loc_conf_t *clcf =
    (ngx_http_core_loc_conf_t *)ngx_http_get_module_loc_conf(r, ngx_http_core_module);

  // 拼装IDX和DAT文件名
  dat_filename->assign((char *)clcf->root.data, clcf->root.len);
  dat_filename->append(grid_name);
  dat_filename->append(".dat");

  idx_filename->assign((char *)clcf->root.data, clcf->root.len);
  idx_filename->append(grid_name);
  idx_filename->append(".idx");
}

// 发送特殊tile，包括land，water，grass，404这四种
static ngx_int_t SendSpecialTile(ngx_http_request_t *r,
                                 int64_t dat_offset) {
  ngx_log_t *log = r->connection->log;
  log->action = (char *)"Send Special Tilefile";

  // 只处理特殊tile，如果进到这里就说明外面出错了
  if (dat_offset >= 0) {
    ngx_log_error(NGX_LOG_ERR, log, 0, "Should not be here, dat_offset %z >= 0",
                 dat_offset);
    abort();
  }

  ngx_http_core_loc_conf_t *clcf =
    (ngx_http_core_loc_conf_t *)ngx_http_get_module_loc_conf(r, ngx_http_core_module);

  // 从root中取特殊图块
  string tile_filename((char *)clcf->root.data, clcf->root.len);

  switch (dat_offset) {
  case kLandPng:
  case kDefaultPng:
    tile_filename.append("/land.png");
    break;
  case kWaterPng:
    tile_filename.append("/water.png");
    break;
  case kGrassPng:
    tile_filename.append("/grass.png");
    break;
  case kBad404Png:
    tile_filename.append("/404.png");
    break;
  default:
    // offset错了，直接在这里返回404.png
    tile_filename.append("/404.png");
    break;
  }

  ngx_log_error(NGX_LOG_DEBUG, log, 0, "Get Special Tilefile: %s with dat_offset: %z",
                tile_filename.c_str(), dat_offset);

  // 打开图片
  ngx_str_t tile_file_path =
    {tile_filename.size(), (u_char *)tile_filename.c_str()};
  ngx_open_file_info_t tile_file_of;
  ngx_memzero(&tile_file_of, sizeof(ngx_open_file_info_t));
  tile_file_of.directio = NGX_MAX_OFF_T_VALUE;

  // 这里很可能因为运维失误，导致404.png图片缺失
  // 所以在启动时最好做一次检查
  log->action = (char *)"Open Special Tilefile";
  if (ngx_open_cached_file(clcf->open_file_cache,
                           &tile_file_path, &tile_file_of, r->pool) != NGX_OK) {
    ngx_log_error(NGX_LOG_ERR, log, ngx_errno,
                  "Open Special Tilefile %s fail, offset: %z", tile_filename.c_str(), dat_offset);
    return NGX_HTTP_NOT_FOUND;
  }

  if (!tile_file_of.is_file) {
    ngx_log_error(NGX_LOG_ERR, log, 0, "Special Tilefile %s isn't file", tile_filename.c_str());
    if (ngx_close_file(tile_file_of.fd) == NGX_FILE_ERROR) {
      ngx_log_error(NGX_LOG_ERR, log, ngx_errno,
                    ngx_close_file_n " \"%V\" failed", tile_file_path);
    }
    return NGX_HTTP_NOT_FOUND;
  }

  log->action = (char *)"Reading Special tile";

  // fill data format, All Are PNG
  r->headers_out.content_type.len = sizeof("image/png") - 1;
  r->headers_out.content_type.data = (u_char*)"image/png";
  r->headers_out.status = NGX_HTTP_OK;
  r->headers_out.content_length_n = tile_file_of.size;
  r->headers_out.last_modified_time = tile_file_of.mtime;

  ngx_int_t rc = ngx_http_send_header(r);
  if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {
    ngx_log_error(NGX_LOG_ERR, log, 0, "ngx_http_send_header %d fail, file %s",
      __LINE__, tile_filename.c_str());
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
  }

  ngx_buf_t *b = (ngx_buf_t *)ngx_pcalloc(r->pool, sizeof(ngx_buf_t));
  if (b == NULL) {
    ngx_log_error(NGX_LOG_ERR, log, 0, "ngx_pcalloc %d fail, file %s",
      __LINE__, tile_filename.c_str());
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
  }
  b->file = (ngx_file_t *)ngx_pcalloc(r->pool, sizeof(ngx_file_t));
  if (b->file == NULL) {
    ngx_log_error(NGX_LOG_ERR, log, 0, "ngx_pcalloc %d fail, file %s",
      __LINE__, tile_filename.c_str());
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
  }

  b->file_pos = 0;
  b->file_last = tile_file_of.size;
  b->in_file = 1;
  b->last_buf = (r == r->main) ? 1 : 0;
  b->last_in_chain = 1;
  b->file->fd = tile_file_of.fd;
  b->file->name = tile_file_path;
  b->file->log = log;
  b->file->directio = 0;

  ngx_chain_t out;
  out.buf = b;
  out.next = NULL;
  return ngx_http_output_filter(r, &out);
}

// 用于返回404.png给用户
static ngx_int_t Send404Tile(ngx_http_request_t *r) {
  return SendSpecialTile(r, kBad404Png);
}

static void log_error(ngx_http_request_t *r, char * msg){
  ngx_log_t *log = r->connection->log;
  ngx_log_error(NGX_LOG_INFO, log, 0, "%s" , msg);
}

// 根据idx和dat文件名，以及计算出来的idx中的offset，读取tile数据
static ngx_int_t SendTile(ngx_http_request_t *r,
                          const string &idx_filename,
                          const string &dat_filename,
                          int32_t idx_index) {
  // 读tile索引信息
  ngx_log_t *log = r->connection->log;
  log->action = (char *)"Open Idx file";
  ngx_http_core_loc_conf_t *clcf =
    (ngx_http_core_loc_conf_t *)ngx_http_get_module_loc_conf(r, ngx_http_core_module);

  ngx_str_t idx_file_path = {idx_filename.size(), (u_char *)idx_filename.c_str()};
  ngx_open_file_info_t idx_file_of;
  ngx_memzero(&idx_file_of, sizeof(ngx_open_file_info_t));
  // tile通常都是连续读取
  idx_file_of.read_ahead = 1024;
  // 因为有pread调用，需要禁用directio
  idx_file_of.directio = NGX_MAX_OFF_T_VALUE;

  if (ngx_open_cached_file(clcf->open_file_cache, &idx_file_path, &idx_file_of, r->pool) != NGX_OK) {
    ngx_log_error(NGX_LOG_ERR, log, ngx_errno, "Open idxfile %s fail, %s",
                  idx_filename.c_str(), strerror(errno));
    return NGX_HTTP_NOT_FOUND;
  }

  if (!idx_file_of.is_file) {
    ngx_log_error(NGX_LOG_ERR, log, 0, "Idxfile %s isn't file", idx_filename.c_str());
    if (ngx_close_file(idx_file_of.fd) == NGX_FILE_ERROR) {
      ngx_log_error(NGX_LOG_ERR, log, ngx_errno, ngx_close_file_n " \"%V\" failed", idx_file_path);
    }
    return NGX_HTTP_NOT_FOUND;
  }
  // 对数据进行完整性检查，包括IDX和DAT文件
  // idx_file_of.fs_size必须是(kGridSize * kGridSize)的整数倍
  // 线上可能有两个版本的idx，根据IDX文件的大小判断版本
  snprintf(log_buffer, 1000, "@idx_index 1=%d@", idx_index); log_error(r, log_buffer);
  int32_t idx_offset = idx_index;
  TileIndexInfoVersion version = V0;
  switch (idx_file_of.fs_size / kBaseIdxFileSize) {
  case sizeof(TileIndexInfoV0):
    version = V0;
    idx_offset *= sizeof(TileIndexInfoV0);
    break;
  case sizeof(TileIndexInfoV1):
    version = V1;
    idx_offset *= sizeof(TileIndexInfoV1);
    break;
  default:
    // should nerver be here
    ngx_log_error(NGX_LOG_ERR, log, 0,
                  "Bad idx file %s, size: %z, Bad IDX Version",
                  idx_filename.c_str(), idx_file_of.fs_size);
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
  }
  snprintf(log_buffer, 1000, "@idx_offset 2=%d@", idx_offset); log_error(r, log_buffer);

  // 读索引，在程序中将dat_offset全部统一成long
  // 虽然在IDX中可能为int也可能为long
  int64_t dat_offset = 0;
  int32_t dat_datalen = 0;

  // 第一步先读offset
  // 老格式IDX的offset为int型，新格式IDX为long型
  const char *version_str = "Int";
  switch (version) {
  case V1:
    {
      snprintf(log_buffer, 1000, "@idx_version = v1 long"); log_error(r, log_buffer);
      version_str = "Long";
      log->action = (char *)"Reading Version Long IDX File";
      TileIndexInfoV1 index = {0};
      int32_t readn = pread(idx_file_of.fd, (void *)(&index), sizeof(index), idx_offset);
      if (readn != sizeof(index)) {
        ngx_log_error(NGX_LOG_ERR, log, ngx_errno,
                      "Read tilefile %s fail, offset %d, readed %d, %s",
                      idx_filename.c_str(), idx_offset, readn, strerror(errno));
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
      }

      // ntohl
      index.offset = TCSWAB64(index.offset);
      dat_offset = index.offset;
    }
    break;
  case V0:
    {
      snprintf(log_buffer, 1000, "@idx_version = v1 int"); log_error(r, log_buffer);

      version_str = "Int";
      log->action = (char *)"Reading Version Int IDX File";
      TileIndexInfoV0 index = {0};
      int32_t readn = pread(idx_file_of.fd, (void *)(&index), sizeof(index), idx_offset);
      if (readn != sizeof(index)) {
        ngx_log_error(NGX_LOG_ERR, log, ngx_errno,
                      "Read tilefile %s fail, offset %d, readed %d, %s",
                      idx_filename.c_str(), idx_offset, readn, strerror(errno));
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
      }
      snprintf(log_buffer, 1000, "@index.offset 3=%d@", index.offset); log_error(r, log_buffer);

      // ntohl，不能直接用dat_offset = TCSWAB32(index.offset);
      // 因为TCSWAB32是宏，会导致bug
      index.offset = TCSWAB32(index.offset);
      snprintf(log_buffer, 1000, "@ TCSWAB32@" ); log_error(r, log_buffer);
      
      snprintf(log_buffer, 1000, "@dat_offset = index.offset 4=%d@", index.offset); log_error(r, log_buffer);

      dat_offset = index.offset;
    }
    break;
  default:
    // 在上面已经做过判断，所以不会到这里
    break;
  }

  ngx_log_error(NGX_LOG_DEBUG, log, 0, "Get dat_offset: %z from Version %s idxfile %s",
                dat_offset, version_str, idx_filename.c_str());

  // 根据offset决定是否要继续下去
  // 正常的数据的offset应该大于或等于0，如果小于0说明是特殊图片
  if (dat_offset < 0) {
    return SendSpecialTile(r, dat_offset);
  }

  // 打开dat文件
  ngx_str_t dat_file_path = {dat_filename.size(), (u_char *)dat_filename.c_str()};
  ngx_open_file_info_t dat_file_of;
  ngx_memzero(&dat_file_of, sizeof(ngx_open_file_info_t));
  // 因为有pread调用，需要禁用directio
  dat_file_of.directio = NGX_MAX_OFF_T_VALUE;

  // 读dat数据获取datalen
  log->action = (char *)"Open Dat file";
  if (ngx_open_cached_file(clcf->open_file_cache, &dat_file_path, &dat_file_of, r->pool) != NGX_OK) {
    ngx_log_error(NGX_LOG_ERR, log, ngx_errno, "Open datfile %s fail", dat_filename.c_str());
    return NGX_HTTP_NOT_FOUND;
  }

  if (!dat_file_of.is_file) {
    ngx_log_error(NGX_LOG_ERR, log, 0, "Datfile %s is_not_file type", dat_filename.c_str());
    if (ngx_close_file(dat_file_of.fd) == NGX_FILE_ERROR) {
      ngx_log_error(NGX_LOG_ERR, log, ngx_errno, ngx_close_file_n " \"%V\" failed", dat_file_path);
    }
    return NGX_HTTP_NOT_FOUND;
  }

  // pread读4字节的datalen，它后面就是data
  log->action = (char *)"Reading tile datalen";
  int32_t readn = pread(dat_file_of.fd, (void *)(&dat_datalen), sizeof(dat_datalen), dat_offset);
  if (readn != sizeof(dat_datalen)) {
    ngx_log_error(NGX_LOG_ERR, log, ngx_errno,
                  "Read datfile %s fail, offset %z, readed %d, %s",
                  dat_filename.c_str(), dat_offset, readn, strerror(errno));
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
  }

  dat_datalen = TCSWAB32(dat_datalen);

  ngx_log_error(NGX_LOG_DEBUG, log, 0, "Get dat_datalen: %d from datfile %s",
                dat_datalen, dat_filename.c_str());

  // 读取Dat File，在这里需要对Dat文件做完整性检查
  // 检查dat文件是否损坏，这种错误必须打印出来
  log->action = (char *)"Reading tile data";
  if (dat_offset + dat_datalen > dat_file_of.size) {
    ngx_log_error(NGX_LOG_ERR, log, 0,
                  "Datfile %s conrrupted, offset %O, datalen %u, filesize %O",
                  dat_filename.c_str(), dat_offset, dat_datalen, dat_file_of.size);
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
  }

  // fill dataformat
  ngx_http_getpng_loc_conf_t *conf;
  conf = (ngx_http_getpng_loc_conf_t *)ngx_http_get_module_loc_conf(r, ngx_module_getpng);

  // 构建返回数据类型
  char content_type[64];
  int32_t content_type_len = snprintf(content_type, sizeof(content_type), 
                                        "image/%.*s", 
                                        (int)conf->format.len, conf->format.data);

  r->headers_out.content_type.len = (size_t)content_type_len;
  r->headers_out.content_type.data = (u_char *)content_type;

  r->headers_out.status = NGX_HTTP_OK;
  r->headers_out.content_length_n = dat_datalen;
  r->headers_out.last_modified_time = dat_file_of.mtime;

  ngx_int_t rc = ngx_http_send_header(r);
  if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {
    ngx_log_error(NGX_LOG_ERR, log, 0, "ngx_http_send_header %d fail %d",
      __LINE__, rc);
    return rc;
  }

  ngx_buf_t *b = (ngx_buf_t *)ngx_pcalloc(r->pool, sizeof(ngx_buf_t));
  if (b == NULL) {
    ngx_log_error(NGX_LOG_ERR, log, 0, "ngx_pcalloc %d fail",
      __LINE__);
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
  }
  b->file = (ngx_file_t *)ngx_pcalloc(r->pool, sizeof(ngx_file_t));
  if (b->file == NULL) {
    ngx_log_error(NGX_LOG_ERR, log, 0, "ngx_pcalloc %d fail",
      __LINE__);
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
  }

  // tile data前面有4字节的datalen
  b->file_pos = dat_offset + 4;
  b->file_last = b->file_pos + dat_datalen;
  b->in_file = 1;
  b->last_buf = (r == r->main) ? 1 : 0;
  b->last_in_chain = 1;
  b->file->fd = dat_file_of.fd;
  b->file->name = dat_file_path;
  b->file->log = log;
  b->file->directio = 0;

  ngx_chain_t out;
  out.buf = b;
  out.next = NULL;
  return ngx_http_output_filter(r, &out);
}

// 实际的处理http request的函数
static ngx_int_t DoHttpHandler(ngx_http_request_t *r) {
  // 目前只支持NGX_HTTP_GET方法，不支持POST
  if (!(r->method & (NGX_HTTP_GET))) {
    return NGX_HTTP_NOT_ALLOWED;
  }

  ngx_int_t rc = ngx_http_discard_request_body(r);
  if (rc != NGX_OK) {
    return rc;
  }

  if (r->args.len == 0) {
    return NGX_HTTP_BAD_REQUEST;
  }
  ngx_log_t *log = r->connection->log;

  // 提取出xyz三个参数，取merge数据只需要xyz。
  log->action = (char *)"Parse argument";
  int32_t x, y, z;
  int8_t c;
  if (ParseArgs(r, &x, &y, &z, &c) != 0) {
    ngx_log_error(NGX_LOG_INFO, log, 0, "ParseArgs fail, %.*s", (int)r->args.len, r->args.data);
    return NGX_HTTP_BAD_REQUEST;
  }

  // 检查参数是否有问题
  if (x < 0 || y < 0 || z < 0 || c < 0) {
    ngx_log_error(NGX_LOG_DEBUG, log, 0, "Bad argument %d %d %d", x, y, z, c);
    return NGX_HTTP_BAD_REQUEST;
  }

  // 根据xyz和request配置，读取tile
  log->action = (char *)"Calc filename & idx_offset";
  string idx_filename;
  string dat_filename;
  GetIdxAndDatFileName(r, x, y, z, c, &idx_filename, &dat_filename);
  //GetIdxAndDatFileName(r, x, y, z, &idx_filename, &dat_filename);

  // 计算idx的index
  int32_t idx_index = (x % kGridSize) * kGridSize + (y % kGridSize);

  ngx_log_error(NGX_LOG_DEBUG, log, 0,
                "Get params zxy: %d_%d_%d, idx_file: %s, idx_index: %d",
                z, x, y, idx_filename.c_str(), idx_index);

  // 获取并发送tile数据
  return SendTile(r, idx_filename, dat_filename, idx_index);
}

static ngx_int_t NgxHttpGetpngHandler(ngx_http_request_t *r) {
  ngx_int_t ret = DoHttpHandler(r);
  
  // 只要ret是错误，则返回404.png
  if (ret >= NGX_HTTP_BAD_REQUEST) {
    return Send404Tile(r);
  } else {
    return ret;
  }
}

static char *ngx_http_getpng(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {
  ngx_http_core_loc_conf_t  *clcf;
  clcf = (ngx_http_core_loc_conf_t *)ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
  clcf->handler = NgxHttpGetpngHandler;
  return NGX_CONF_OK;
}

static void *ngx_http_getpng_create_loc_conf(ngx_conf_t *cf) {
  ngx_http_getpng_loc_conf_t *conf =
    (ngx_http_getpng_loc_conf_t *)ngx_pcalloc(cf->pool, sizeof(ngx_http_getpng_loc_conf_t));
  if (conf == NULL) {
    return NGX_CONF_ERROR;
  }

  ngx_str_null(&conf->format);
  return conf;
}

static char *ngx_http_getpng_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child) {
  ngx_http_getpng_loc_conf_t *prev = (ngx_http_getpng_loc_conf_t *)parent;
  ngx_http_getpng_loc_conf_t *conf = (ngx_http_getpng_loc_conf_t *)child;
  ngx_conf_merge_str_value(conf->format, prev->format, "png");

  return NGX_CONF_OK;
}

