var _ = require('../util');
var Com = require('./index');
var d3 = require('../libs/d3');
/**
 * è½´
 * @constructor
 */
function Axis(options) {
  this.$options = {
    key : 'x',
    type : 'defaults',
    orient : 'bottom',
    padding : 0.3,
    min : 0,
    max : null,
  };
  this.x;
  this.axisx;
  this.el;
  this.valid = true;
  this.msg;
  this._init(options);
  this._valid();
}

Com.extend(Axis, {
  _valid : function () {
    var opt = this.$options;
    var self = this;
    if (!_.has(opt._data[0], opt.key) && !_.has(opt, 'min') && !_.has(opt, 'max')) {
      this.msg = 'axis arguments error. there is no ' + opt.key + ' in data.';
      opt.key = _.keys(opt._data[0])[0];
      this.valid = false;
    }
    var types = ['defaults', 'category', 'time'];
    if (_.indexOf(types, opt.type.toLowerCase()) === -1) {
      this.msg = 'axis arguments error. there is no ' + opt.type + ' in types.';
      opt.type = types[0];
      this.valid = false;
    }
    opt.type = _.initialUpperCase(opt.type);
    var orients = ['left', 'top', 'right', 'bottom'];
    if (_.indexOf(orients, opt.orient.toLowerCase()) === -1) {
      this.msg = 'axis arguments error. there is no ' + opt.orient + ' in orients.';
      opt.orient = orients[0];
      this.valid = false;
    }
    opt.orient = _.initialUpperCase(opt.orient);
  },
  render : function () {
    var opt = this.$options;
    if (!this.valid) {
      this.emit('error', {msg: this.msg});
    }
    this['cal' + opt.orient]();
  },
  calLeft : function () {
    var opt = this.$options;
    var x = this.x = this['axis' + opt.type].call(this, [opt.height, 0]);
    var xAxis = this.axisx = d3.svg.axis()
      .scale(x)
      .orient('left')
      .tickSize(1);
    var gx = this.el = opt.svg.append("g")
      .attr("class", "axis")
      .call(xAxis);
  },
  calRight : function () {
    var opt = this.$options;
    var x = this.x = this['axis' + opt.type].call(this, [opt.height, 0]);
    var xAxis = this.axisx = d3.svg.axis()
      .scale(x)
      .orient('right')
      .tickSize(1);
    var gx = this.el = opt.svg.append("g")
      .attr({
        "class": "axis",
        "transform": "translate(" + opt.width + ", 0)"
      })
      .call(xAxis);
  },
  calTop : function () {
    var opt = this.$options;
    var x = this.x = this['axis' + opt.type].call(this, [0, opt.width]);
    var xAxis = this.axisx = d3.svg.axis()
      .scale(x)
      .orient('top')
      .tickSize(1);
    var gx = this.el = opt.svg.append("g")
      .attr("class", "axis")
      .call(xAxis);
  },
  calBottom : function () {
    var opt = this.$options;
    var x = this.x = this['axis' + opt.type].call(this, [0, opt.width]);
    var xAxis = this.axisx = d3.svg.axis()
      .scale(x)
      .orient('bottom')
      .tickSize(1);
    var gx = this.el = opt.svg.append("g")
      .attr("class", "axis")
      .attr("transform", "translate(0," + opt.height + ")")
      .call(xAxis);
  },
  axisDefaults : function (args) {
    var opt = this.$options;
    var x = d3.scale.linear().range(args);
    var extent;
    if (_.isNumber(opt.min) && _.isNumber(opt.max)) {
      extent = [opt.min, opt.max];
    } else {
      extent = d3.extent(_.map(opt._data, function (obj) {
        return obj[opt.key];
      }));
      if (_.isNumber(opt.min)) {
        extent[0] = opt.min;
      }
      if (_.isNumber(opt.max)) {
        extent[1] = opt.max;
      }
    }
    x.domain(extent);
    return x;
  },
  axisCategory : function (args) {
    var opt = this.$options;
    var x = d3.scale.ordinal().rangeBands(args, opt.padding / 2, opt.padding);
    var extent;
    if (_.isNumber(opt.min) && _.isNumber(opt.max)) {
      extent = [opt.min, opt.max];
    } else {
      extent = _.map(opt._data, function (obj) {
        return obj[opt.key];
      });
    }
    x.domain(extent);
    return x;
  },
  axisTime : function (args) {
    var opt = this.$options;
    var x = d3.time.scale().range(args);
    var extent;
    if (_.isDate(opt.min) && _.isDate(opt.max)) {
      extent = [opt.min, opt.max];
    } else {
      extent = d3.extent(_.map(opt._data, function (obj) {
        return obj[opt.key];
//      return d3.time.format(opt.format).parse(obj[opt.key]);
      }));
    }
    x.domain(extent);
    return x;
  },
  getX : function () {
    return this.x;
  },
  getAxisX : function () {
    return this.axisx;
  },
  getMin : function () {
    return _.first(this.x.domain());
  },
  getMax : function () {
    return _.last(this.x.domain());
  },
  updateKey : function (obj) {
    this._init(obj);
    var opt = this.$options;
    var extent;
    if (_.isNumber(opt.min) && _.isNumber(opt.max)) {
      extent = [opt.min, opt.max];
    } else {
      extent = _.map(opt._data, function (obj) {
        return obj[opt.key];
      });
    }
    this.x.domain(extent);
    this.el.call(this.axisx);
  }
});

module.exports = Axis;
